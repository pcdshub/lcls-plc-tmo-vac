

DUTs
----


E_STATES
^^^^^^^^

::

    {attribute 'qualified_only'}
    {attribute 'strict'}
    TYPE E_STATES :
    (
    	INIT := 0,
    	SETUP,
    	OVERRIDE,
    	READY,
    	NOT_SAFE
    );
    END_TYPE


Related:
    * `E_STATES`_


GVLs
----


GVL_COM
^^^^^^^

::

    VAR_GLOBAL
    	// Define COM Ports/Buffers incl. library Tc2_SerialCom
    	
    	//PA1K4_IP1_PTM_01 , 02 and 03 
    	//K4S2_02_E10
    	K4S2_02_E10_SerialRXBuffer : ComBuffer;
    	K4S2_02_E10_SerialTXBuffer : ComBuffer;
    	
    	// Serial Terminal
    	K4S2_02_E10_fbSerialLineControl: SerialLineControl;

    	//SERIAL IO //K4S2_02_E10 (EL6021)
    	{attribute	'TcLinkTo'	:=	'.Status:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Status;
    								 .D[0]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 0;
    								 .D[1]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 1;
    								 .D[2]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 2;
    								 .D[3]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 3;
    								 .D[4]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 4;
    								 .D[5]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 5;
    								 .D[6]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 6;
    								 .D[7]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 7;
    								 .D[8]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 8;
    								 .D[9]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 9;
    								 .D[10]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 10;
    								 .D[11]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 11;
    								 .D[12]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 12;
    								 .D[13]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 13;
    								 .D[14]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 14;
    								 .D[15]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 15;
    								 .D[16]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 16;
    								 .D[17]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 17;
    								 .D[18]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 18;
    								 .D[19]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 19;
    								 .D[20]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 20;
    								 .D[21]:=TIIB[K4S2_02_E10 (EL6021)]^COM TxPDO-Map Inputs^Data In 21;
    	'}
    	K4S2_02_E10_stComIn		AT %I*	:	EL6inData22B; 
    	{attribute	'TcLinkTo'	:=	'.Ctrl:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Ctrl;
    								 .D[0]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 0;
    								 .D[1]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 1;
    								 .D[2]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 2;
    								 .D[3]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 3;
    								 .D[4]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 4;
    								 .D[5]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 5;
    								 .D[6]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 6;
    								 .D[7]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 7;
    								 .D[8]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 8;
    								 .D[9]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 9;
    								 .D[10]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 10;
    								 .D[11]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 11;
    								 .D[12]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 12;
    								 .D[13]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 13;
    								 .D[14]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 14;
    								 .D[15]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 15;
    								 .D[16]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 16;
    								 .D[17]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 17;
    								 .D[18]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 18;
    								 .D[19]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 19;
    								 .D[20]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 20;
    								 .D[21]:=TIIB[K4S2_02_E10 (EL6021)]^COM RxPDO-Map Outputs^Data Out 21;
    	'}
    	K4S2_02_E10_stComOut		AT %Q*	:	EL6outData22B;
    	
    	
    	//Granite 2
    	//LI3K4_IP1_OUT_PTM_01-TM1K4_PTM_01-IM5K4_PPM_PTM_01
    	//K4S6_01_E5 (EL6021)
    	K4S6_01_E5_SerialRXBuffer : ComBuffer;
    	K4S6_01_E5_SerialTXBuffer : ComBuffer;
    	
    	// Serial Terminal
    	K4S6_01_E5_fbSerialLineControl: SerialLineControl;

    	//Serial IO
    		{attribute	'TcLinkTo'	:=	'.Status:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Status;
    								 .D[0]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 0;
    								 .D[1]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 1;
    								 .D[2]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 2;
    								 .D[3]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 3;
    								 .D[4]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 4;
    								 .D[5]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 5;
    								 .D[6]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 6;
    								 .D[7]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 7;
    								 .D[8]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 8;
    								 .D[9]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 9;
    								 .D[10]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 10;
    								 .D[11]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 11;
    								 .D[12]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 12;
    								 .D[13]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 13;
    								 .D[14]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 14;
    								 .D[15]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 15;
    								 .D[16]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 16;
    								 .D[17]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 17;
    								 .D[18]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 18;
    								 .D[19]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 19;
    								 .D[20]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 20;
    								 .D[21]:=TIIB[K4S6_01_E5 (EL6021)]^COM TxPDO-Map Inputs^Data In 21;
    	'}
    	K4S6_01_E5_stComIn		AT %I*	:	EL6inData22B; 
    	{attribute	'TcLinkTo'	:=	'.Ctrl:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Ctrl;
    								 .D[0]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 0;
    								 .D[1]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 1;
    								 .D[2]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 2;
    								 .D[3]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 3;
    								 .D[4]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 4;
    								 .D[5]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 5;
    								 .D[6]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 6;
    								 .D[7]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 7;
    								 .D[8]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 8;
    								 .D[9]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 9;
    								 .D[10]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 10;
    								 .D[11]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 11;
    								 .D[12]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 12;
    								 .D[13]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 13;
    								 .D[14]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 14;
    								 .D[15]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 15;
    								 .D[16]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 16;
    								 .D[17]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 17;
    								 .D[18]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 18;
    								 .D[19]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 19;
    								 .D[20]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 20;
    								 .D[21]:=TIIB[K4S6_01_E5 (EL6021)]^COM RxPDO-Map Outputs^Data Out 21;
    	'}
    	K4S6_01_E5_stComOut		AT %Q*	:	EL6outData22B;

    	//IM4K4_PPM_PTM_01
    	//K4S2_02_E17 (EL6001)
    	K4S2_02_E17_SerialRXBuffer : ComBuffer;
    	K4S2_02_E17_SerialTXBuffer : ComBuffer;
    	
    	// Serial Terminal
    	K4S2_02_E17_fbSerialLineControl: SerialLineControl;
    		//Serial IO
    		{attribute	'TcLinkTo'	:=	'.Status:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Status;
    								 .D[0]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 0;
    								 .D[1]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 1;
    								 .D[2]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 2;
    								 .D[3]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 3;
    								 .D[4]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 4;
    								 .D[5]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 5;
    								 .D[6]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 6;
    								 .D[7]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 7;
    								 .D[8]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 8;
    								 .D[9]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 9;
    								 .D[10]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 10;
    								 .D[11]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 11;
    								 .D[12]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 12;
    								 .D[13]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 13;
    								 .D[14]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 14;
    								 .D[15]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 15;
    								 .D[16]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 16;
    								 .D[17]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 17;
    								 .D[18]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 18;
    								 .D[19]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 19;
    								 .D[20]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 20;
    								 .D[21]:=TIIB[K4S2_02_E17 (EL6001)]^COM Inputs^Data In 21;
    	'}
    	K4S2_02_E17_stComIn		AT %I*	:	EL6inData22B; 
    	{attribute	'TcLinkTo'	:=	'.Ctrl:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Ctrl;
    								 .D[0]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 0;
    								 .D[1]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 1;
    								 .D[2]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 2;
    								 .D[3]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 3;
    								 .D[4]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 4;
    								 .D[5]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 5;
    								 .D[6]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 6;
    								 .D[7]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 7;
    								 .D[8]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 8;
    								 .D[9]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 9;
    								 .D[10]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 10;
    								 .D[11]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 11;
    								 .D[12]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 12;
    								 .D[13]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 13;
    								 .D[14]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 14;
    								 .D[15]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 15;
    								 .D[16]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 16;
    								 .D[17]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 17;
    								 .D[18]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 18;
    								 .D[19]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 19;
    								 .D[20]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 20;
    								 .D[21]:=TIIB[K4S2_02_E17 (EL6001)]^COM Outputs^Data Out 21;
    	'}
    	K4S2_02_E17_stComOut		AT %Q*	:	EL6outData22B;
    	
    	//LI1K4_IP1_PTM_01
    	//K4S2_02_E18 (EL6001)

    	// Define COM Ports/Buffers incl. library Tc2_SerialCom
    	K4S2_02_E18_SerialRXBuffer : ComBuffer;
    	K4S2_02_E18_SerialTXBuffer : ComBuffer;
    	
    	// Serial Terminal
    	K4S2_02_E18_fbSerialLineControl: SerialLineControl;

    	//SERIAL IO
    	{attribute	'TcLinkTo'	:=	'.Status:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Status;
    								 .D[0]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 0;
    								 .D[1]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 1;
    								 .D[2]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 2;
    								 .D[3]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 3;
    								 .D[4]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 4;
    								 .D[5]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 5;
    								 .D[6]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 6;
    								 .D[7]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 7;
    								 .D[8]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 8;
    								 .D[9]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 9;
    								 .D[10]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 10;
    								 .D[11]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 11;
    								 .D[12]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 12;
    								 .D[13]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 13;
    								 .D[14]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 14;
    								 .D[15]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 15;
    								 .D[16]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 16;
    								 .D[17]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 17;
    								 .D[18]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 18;
    								 .D[19]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 19;
    								 .D[20]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 20;
    								 .D[21]:=TIIB[K4S2_02_E18 (EL6001)]^COM Inputs^Data In 21;
    	'}
    	K4S2_02_E18_stComIn		AT %I*	:	EL6inData22B;
    	{attribute	'TcLinkTo'	:=	'.Ctrl:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Ctrl;
    								 .D[0]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 0;
    								 .D[1]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 1;
    								 .D[2]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 2;
    								 .D[3]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 3;
    								 .D[4]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 4;
    								 .D[5]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 5;
    								 .D[6]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 6;
    								 .D[7]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 7;
    								 .D[8]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 8;
    								 .D[9]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 9;
    								 .D[10]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 10;
    								 .D[11]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 11;
    								 .D[12]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 12;
    								 .D[13]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 13;
    								 .D[14]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 14;
    								 .D[15]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 15;
    								 .D[16]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 16;
    								 .D[17]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 17;
    								 .D[18]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 18;
    								 .D[19]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 19;
    								 .D[20]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 20;
    								 .D[21]:=TIIB[K4S2_02_E18 (EL6001)]^COM Outputs^Data Out 21;
    	'}
    	K4S2_02_E18_stComOut		AT %Q*	:	EL6outData22B;
    	
    	
    	
    END_VAR




GVL_FEE_Device
^^^^^^^^^^^^^^

::

    //{attribute 'qualified_only'}
    VAR_GLOBAL

    (* upstream vacuum ok *)
       {attribute 'pytmc' :=' pv: USVAC:OK:HI '}
       {attribute 'TcLinkTo' := 	' := 	TIIB[CX0_E2_EXILK (EL1008)]^Channel 1^Input	'}	
       USVacOk_HI AT%I* : BOOL; (* upstream vacuum <10E-6, for mirror VGC interlock *)
     
     	{attribute 'pytmc' :=' pv: USVAC:OK:LO '}
       {attribute 'TcLinkTo' := 	'	:= 	TIIB[CX0_E2_EXILK (EL1008)]^Channel 3^Input	'}	  
       USVacOk_LO AT%I* : BOOL; (* upstream vacuum <10E-4, for Ion pump interlock *)


    (* Isolation gate valves*)

    	{attribute 'pytmc' :=' pv: TV1K4:VGC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[B940_K4S20_EB1  (EP2338-0002)]^Channel 1^Input;
    								 .i_xClsLS	:=	TIIB[B940_K4S20_EB1  (EP2338-0002)]^Channel 2^Input;
    								.q_xOPN_DO	:=	TIIB[B940_K4S20_EB1  (EP2338-0002)]^Channel 11^Output'}
    	TV1K4_VGC_01: FB_VGC;
    	
    	{attribute 'pytmc' :=' pv: TV1K4:VGC:02 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[B940_K4S20_EB1  (EP2338-0002)]^Channel 5^Input;
    								 .i_xClsLS	:=	TIIB[B940_K4S20_EB1  (EP2338-0002)]^Channel 6^Input;
    								 .q_xOPN_DO	:=	TIIB[B940_K4S20_EB1  (EP2338-0002)]^Channel 15^Output'}	
     	TV1K4_VGC_02: FB_VGC;

    	{attribute 'pytmc' :=' pv: ST3K4:PPS:VGC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[B940_K4S33_EB1 (EP2338-0002)]^Channel 1^Input;
    								 .i_xClsLS	:=	TIIB[B940_K4S33_EB1 (EP2338-0002)]^Channel 2^Input;
    								 .q_xOPN_DO	:=	TIIB[B940_K4S33_EB1 (EP2338-0002)]^Channel 11^Output'}	
    	ST3K4_PPS_VGC_01 : FB_VGC;
    	
    (* Pirani & Cold Cathode*)

    	

    	{attribute 'pytmc' :=' pv: TV1K4:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_K4S20_EB2  (EP3174-0002)]^AI Standard Channel 1^Value	'}
    	TV1K4_GPI_01 : FB_MKS275;
    	
    	
    	{attribute 'pytmc' :=' pv: TV1K4:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_K4S20_EB2  (EP3174-0002)]^AI Standard Channel 2^Value;
    								 .q_xHV_DIS		:= 	TIIB[B940_K4S20_EB3 (EP2624-0002)]^Channel 1^Output	'}	
    	TV1K4_GCC_01 : FB_MKS500;
    	
    	{attribute 'pytmc' :=' pv: ST1K4:TEST:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_K4S24_EB1 (EP3174-0002)]^AI Standard Channel 1^Value		'}
    	ST1K4_TEST_GPI_01 : FB_MKS275;
    	
    			
    	{attribute 'pytmc' :=' pv: ST1K4:TEST:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_K4S24_EB1 (EP3174-0002)]^AI Standard Channel 2^Value;
    								 .q_xHV_DIS		:= 	TIIB[B940_K4S24_EB2 (EP2624-0002)]^Channel 1^Output	'}	
    	ST1K4_TEST_GCC_01 : FB_MKS500;
    	
    	
    	{attribute 'pytmc' :=' pv: ST2K4:BCS:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_K4S28_EB1 (EP3174-0002)]^AI Standard Channel 1^Value	'}
    	ST2K4_BCS_GPI_01 : FB_MKS275;	
    	
    	{attribute 'pytmc' :=' pv: ST2K4:BCS:GCC:01 '}	
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_K4S28_EB1 (EP3174-0002)]^AI Standard Channel 2^Value;
    								 .q_xHV_DIS		:= 	TIIB[B940_K4S28_EB2 (EP2624-0002)]^Channel 1^Output	'}	
    	ST2K4_BCS_GCC_01 : FB_MKS500;		

    						 
    	{attribute 'pytmc' :=' pv: PC4K4:XTES:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_K4S33_EB2 (EP3174-0002)]^AI Standard Channel 1^Value	'}
    	PC4K4_XTES_GPI_01 : FB_MKS275;

    	{attribute 'pytmc' :=' pv: PC4K4:XTES:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_K4S33_EB2 (EP3174-0002)]^AI Standard Channel 2^Value;
    								 .q_xHV_DIS		:= 	TIIB[B940_K4S33_EB3 (EP2624-0002)]^Channel 1^Output	'}	
    	
    	PC4K4_XTES_GCC_01 : FB_MKS500;
    	
    	

    	
    (* Ion Pumps *)	
    	
    (*example
    	{attribute 'TcLinkTo' := 	'.i_iPRESS		:=	TIIB[QPC_E1_EL3064]^AI Standard Channel 1^Value;
    								 .i_xSP_DI		:= 	TIIB[QPC_E2_EL1004]^Channel 1^Input;
    								 .q_xHVEna_DO	:= 	TIIB[QPC_E3_EL2794]^Channel 1^Output	'}
    	{attribute 'pytmc' := '
    		pv: RTDSL0:VAC:PIP:01
    		io: io
    	'}
    	RTDSL0_PIP_01 : FB_PIP_Gamma;
    	*)

    	{attribute 'pytmc' :=' 
    			pv: MR1K4:SOMS:PIP:01 '
     		}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS		:=	TIIB[CX0_E6_QPC1 (EL3064)]^AI Standard Channel 1^Value;
    								 .i_xSP_DI		:= 	TIIB[CX0_E7_QPC1 (EL1004)]^Channel 1^Input;
    								 .q_xHVEna_DO	:= 	TIIB[CX0_E8_QPC1 (EL2794)]^Channel 1^Output
    	'}
    	MR1K4_SOMS_PIP_01 : FB_PIP_Gamma;
    	
    	{attribute 'pytmc' :=' pv: ST1K4:TEST:PIP:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS		:=	TIIB[CX0_E6_QPC1 (EL3064)]^AI Standard Channel 2^Value;
    								 .i_xSP_DI		:= 	TIIB[CX0_E7_QPC1 (EL1004)]^Channel 2^Input;
    								 .q_xHVEna_DO	:= 	TIIB[CX0_E8_QPC1 (EL2794)]^Channel 2^Output
    	'}	
    	ST1K4_TEST_PIP_01 : FB_PIP_Gamma;	
    	
    	{attribute 'pytmc' :=' pv: ST2K4:BCS:PIP:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS		:=	TIIB[CX0_E6_QPC1 (EL3064)]^AI Standard Channel 3^Value;
    								 .i_xSP_DI		:= 	TIIB[CX0_E7_QPC1 (EL1004)]^Channel 3^Input;
    								 .q_xHVEna_DO	:= 	TIIB[CX0_E8_QPC1 (EL2794)]^Channel 3^Output
    	'}
    	ST2K4_BCS_PIP_01 : FB_PIP_Gamma;	

    	{attribute 'pytmc' :=' pv: ST3K4:PPS:PIP:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS		:=	TIIB[CX0_E6_QPC1 (EL3064)]^AI Standard Channel 4^Value;
    								 .i_xSP_DI		:= 	TIIB[CX0_E7_QPC1 (EL1004)]^Channel 4^Input;
    								 .q_xHVEna_DO	:= 	TIIB[CX0_E8_QPC1 (EL2794)]^Channel 4^Output
    	'}
    	ST3K4_PPS_PIP_01 : FB_PIP_Gamma;		
    	
    	{attribute 'pytmc' :=' pv: PC4K4:XTES:PIP:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS		:=	TIIB[CX0_E9_QPC2 (EL3064)]^AI Standard Channel 1^Value;
    								 .i_xSP_DI		:= 	TIIB[CX0_E10_QPC2 (EL1004)]^Channel 1^Input;
    								 .q_xHVEna_DO	:= 	TIIB[CX0_E11_QPC2 (EL2794)]^Channel 1^Output
    	'}
    	PC4K4_XTES_PIP_01 : FB_PIP_Gamma;	

    	{attribute 'pytmc' :=' pv: TV1K4:PIP:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS		:=	TIIB[CX0_E9_QPC2 (EL3064)]^AI Standard Channel 3^Value;
    								 .i_xSP_DI		:= 	TIIB[CX0_E10_QPC2 (EL1004)]^Channel 3^Input;
    								 .q_xHVEna_DO	:= 	TIIB[CX0_E11_QPC2 (EL2794)]^Channel 3^Output
    	'}
    	TV1K4_PIP_01 : FB_PIP_Gamma;

    	
    	
    	

    END_VAR




GVL_FS_Devices
^^^^^^^^^^^^^^

::

    VAR_GLOBAL
    	(*Global VFS mode selector for all 3 fast shutter valves (TV1K4,MR3K4,MR4K4)*)
        {attribute 'pytmc' := '
        	pv:  TMO:VFS_2OO3_MODE
    		io: io
    	'}
    	eVFS2OO3Mode_TMO : E_2OO3_MODE;

    	(*
    	{attribute 'pytmc' := '
    		pv: TV1K4:VFS:01
    	'}

    	{attribute 'TcLinkTo' := 	'.q_xPress_OK		:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xPress_OK;
    								 .q_xOPN_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xOPN_SW;
    								 .q_xCLS_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xCLS_SW;
    								 .q_xVAC_FAULT_Reset:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xVAC_FAULT_Reset;
    								 .q_xOverrideMode	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xOverrideMode;
    								 .q_xOverrideOpen	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xOverrideOpen;
    								 .i_xTrigger		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xTrigger;
    								 .i_xVFS_Open		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xVFS_Open;
    								 .i_xVFS_Closed		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xVFS_Closed;
    								 .i_xVAC_FAULT_OK	:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xVAC_FAULT_OK;
    								 .i_xMPS_OK			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xMPS_OK;
    								 .i_eVFS_State		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_eVFS_State;
    								 .q_xVetoValveOpenDO := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xVetoValveOpenDO;
    								 .q_xVetoValveClosed := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xVetoValveClosed '}
    	
    	TV1K4_VFS_Interface : FB_VFS_Interface;


    	{attribute 'TcLinkTo' := 	'
    		.q_xClose_A	:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E2-FSV (EL2202)^Channel 1^Output;
    		.q_xClose_B	:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E2-FSV (EL2202)^Channel 2^Output;
    		.q_xClose_C	:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E3-FSV (EL2202)^Channel 1^Output;
    		.q_xOPN_DO	:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E3-FSV (EL2202)^Channel 2^Output;
    		.i_xClsLS	:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E1-FSV (EL1004)^Channel 1^Input;
    		.i_xOpnLS	:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E1-FSV (EL1004)^Channel 2^Input;
    		.i_xTrigger := 	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5_MKS937B (EL1124)^Channel 1^Input '}
    	TV1K4_VFS_1 : FB_VFS;
    	*)

    	{attribute 'pytmc' :=' pv: TV1K4:VFS:01 '}
    	{attribute 'TcLinkTo' := 	'.q_e2OO3_MODE		:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_e2OO3_MODE;
    								 .q_xPRESS_OK_IG1	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xPress_OK_IG1;
    								 .q_xPRESS_OK_IG2	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xPress_OK_IG2;
    								 .q_xPRESS_OK_IG3	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xPress_OK_IG3;
    								 .q_xOPN_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xOPN_SW;
    								 .q_xCLS_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xCLS_SW;
    								 .q_xVAC_FAULT_Reset := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xVAC_FAULT_Reset;
    								 .q_xOverrideMode	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xOverrideMode;
    								 .q_xOverrideOpen	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xOverrideOpen;
    								 .i_xTrigger		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xTrigger;
    								 .i_xVFS_Open		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xVFS_Open;
    								 .i_xVFS_Closed		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xVFS_Closed;
    								 .i_xVAC_FAULT_OK	:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xVAC_FAULT_OK;
    								 .i_xMPS_OK			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xMPS_OK;
    								 .i_eVFS_State		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_eVFS_State;
    								 .q_xVetoValveOpenDO := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xVetoValveOpenDO;
    								 .q_xVetoValveClosed := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.TV1K4_VFS_1.i_xVetoValveClosed;
    								 .i_nFltCount_IG1	:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_nFltCount_IG1;
    								 .i_nFltCount_IG2	:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_nFltCount_IG2;
    								 .i_nFltCount_IG3	:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_nFltCount_IG3 '}
    	TV1K4_VFS_Interface : FB_VFS_2OO3Interface;

    	{attribute 'TcLinkTo' := 	'.q_xClose_A	:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E2-FSV (EL2202)^Channel 1^Output;
    								 .q_xClose_B	:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E2-FSV (EL2202)^Channel 2^Output;
    								 .q_xClose_C	:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E3-FSV (EL2202)^Channel 1^Output;
    								 .q_xOPN_DO		:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E3-FSV (EL2202)^Channel 2^Output;
    								 .i_xClsLS		:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E1-FSV (EL1004)^Channel 1^Input;
    								 .i_xOpnLS		:=	TIIB[B940_K4S20_EK0  (EK1100)]^K4S20-E1-FSV (EL1004)^Channel 2^Input;
    								 .i_xTriggerIG1	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5_MKS937B (EL1124)^Channel 1^Input;
    								 .i_xTriggerIG2	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5_MKS937B (EL1124)^Channel 2^Input;
    								 .i_xTriggerIG3	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5A_MKS937B (EL1124)^Channel 1^Input '}
    	TV1K4_VFS_1 : FB_VFS_2OO3;
    	
    //	{attribute 'TcLinkTo' := 	'TV1K4_VFS_1_VAC_FAULT_OK	 := 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.TV1K4_VFS_1.q_xVAC_FAULT_OK; '}
    //	TV1K4_VFS_1_VAC_FAULT_OK  AT %I* : BOOL;
    	(*
    	{attribute 'pytmc' := '
    		pv: MR3K4:KBO:VFS:01
    	'}
    	
    	{attribute 'TcLinkTo' := 	'.q_xPress_OK		:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xPress_OK;
    								 .q_xOPN_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xOPN_SW;
    								 .q_xCLS_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xCLS_SW;
    								 .q_xVAC_FAULT_Reset:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xVAC_FAULT_Reset;
    								 .q_xOverrideMode	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xOverrideMode;
    								 .q_xOverrideOpen	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xOverrideOpen;
    								 .i_xTrigger		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xTrigger;
    								 .i_xVFS_Open		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xVFS_Open;
    								 .i_xVFS_Closed		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xVFS_Closed;
    								 .i_xVAC_FAULT_OK	:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xVAC_FAULT_OK;
    								 .i_xMPS_OK			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xMPS_OK;
    								 .i_eVFS_State		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_eVFS_State;
    								 .q_xVetoValveOpenDO := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xVetoValveOpenDO;
    								 .q_xVetoValveClosed := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xVetoValveClosed
    	'}

    	MR3K4_KBO_VFS_Interface : FB_VFS_Interface;	

    	{attribute 'TcLinkTo' := 	'
    		.q_xClose_A	:=	TIIB[K4S2_01_E3_VFS (EL2202)]^Channel 1^Output;
    		.q_xClose_B	:=	TIIB[K4S2_01_E3_VFS (EL2202)]^Channel 2^Output;
    		.q_xClose_C	:=	TIIB[K4S2_01_E4_VFS (EL2202)]^Channel 1^Output;
    		.q_xOPN_DO	:=	TIIB[K4S2_01_E4_VFS (EL2202)]^Channel 2^Output;
    		.i_xClsLS	:=	TIIB[K4S2_01_E1_VFS (EL1004)]^Channel 1^Input;
    		.i_xOpnLS	:=	TIIB[K4S2_01_E1_VFS (EL1004)]^Channel 2^Input;
    		.i_xTrigger :=  TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5_MKS937B (EL1124)^Channel 1^Input'}
    	MR3K4_KBO_VFS_1 : FB_VFS;
    	*)

    	{attribute 'pytmc' :=' pv: MR3K4:KBO:VFS:01 '}
    	{attribute 'TcLinkTo' := 	'.q_e2OO3_MODE		:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_e2OO3_MODE;
    								 .q_xPRESS_OK_IG1	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xPress_OK_IG1;
    								 .q_xPRESS_OK_IG2	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xPress_OK_IG2;
    								 .q_xPRESS_OK_IG3	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xPress_OK_IG3;
    								 .q_xOPN_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xOPN_SW;
    								 .q_xCLS_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xCLS_SW;
    								 .q_xVAC_FAULT_Reset := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xVAC_FAULT_Reset;
    								 .q_xOverrideMode	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xOverrideMode;
    								 .q_xOverrideOpen	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xOverrideOpen;
    								 .i_xTrigger		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xTrigger;
    								 .i_xVFS_Open		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xVFS_Open;
    								 .i_xVFS_Closed		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xVFS_Closed;
    								 .i_xVAC_FAULT_OK	:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xVAC_FAULT_OK;
    								 .i_xMPS_OK			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xMPS_OK;
    								 .i_eVFS_State		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_eVFS_State;
    								 .q_xVetoValveOpenDO := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xVetoValveOpenDO;
    								 .q_xVetoValveClosed := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.i_xVetoValveClosed;
    								 .i_nFltCount_IG1	:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_nFltCount_IG1;
    								 .i_nFltCount_IG2	:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_nFltCount_IG2;
    								 .i_nFltCount_IG3	:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_nFltCount_IG3 '}
    	MR3K4_KBO_VFS_Interface : FB_VFS_2OO3Interface;

    	{attribute 'TcLinkTo' := 	'.q_xClose_A	:=	TIIB[K4S2_01_E3_VFS (EL2202)]^Channel 1^Output;
    								 .q_xClose_B	:=	TIIB[K4S2_01_E3_VFS (EL2202)]^Channel 2^Output;
    								 .q_xClose_C	:=	TIIB[K4S2_01_E4_VFS (EL2202)]^Channel 1^Output;
    								 .q_xOPN_DO		:=	TIIB[K4S2_01_E4_VFS (EL2202)]^Channel 2^Output;
    								 .i_xClsLS		:=	TIIB[K4S2_01_E1_VFS (EL1004)]^Channel 1^Input;
    								 .i_xOpnLS		:=	TIIB[K4S2_01_E1_VFS (EL1004)]^Channel 2^Input;
    								 .i_xTriggerIG1	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5_MKS937B (EL1124)^Channel 1^Input;
    								 .i_xTriggerIG2	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5_MKS937B (EL1124)^Channel 2^Input;
    								 .i_xTriggerIG3	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5A_MKS937B (EL1124)^Channel 1^Input '}
    	MR3K4_KBO_VFS_1 : FB_VFS_2OO3;
    	
    //	{attribute 'TcLinkTo' := 	'TV1K4_VFS_1_VAC_FAULT_OK	 := 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR3K4_KBO_VFS_1.q_xVAC_FAULT_OK; '}
    //	MR3K4_KBO_VFS_1_VAC_FAULT_OK  AT %I* : BOOL;
    	(*
    	{attribute 'pytmc' := '
    		pv: MR4K4:KBO:VFS:01
    	'}

    	{attribute 'TcLinkTo' := 	'.q_xPress_OK		:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xPress_OK;
    								 .q_xOPN_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xOPN_SW;
    								 .q_xCLS_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xCLS_SW;
    								 .q_xVAC_FAULT_Reset:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xVAC_FAULT_Reset;
    								 .q_xOverrideMode	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xOverrideMode;
    								 .q_xOverrideOpen	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xOverrideOpen;
    								 .i_xTrigger		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_xTrigger;								                       
    								 .i_xVFS_Open		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_xVFS_Open;
    								 .i_xVFS_Closed		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_xVFS_Closed;
    								 .i_xVAC_FAULT_OK	:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_xVAC_FAULT_OK;
    								 .i_xMPS_OK			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_xMPS_OK;
    								 .i_eVFS_State		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_eVFS_State;
                                     .q_xVetoValveOpenDO := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xVetoValveOpenDO;
    								 .q_xVetoValveClosed := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xVetoValveClosed	
    	'}
    	
    	
    	
    	MR4K4_KBO_VFS_Interface : FB_VFS_Interface;	
    	
    	{attribute 'TcLinkTo' := 	'
    		.q_xClose_A	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E3 (EL2202)^Channel 1^Output;
    		.q_xClose_B	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E3 (EL2202)^Channel 2^Output;
    		.q_xClose_C	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E4 (EL2202)^Channel 1^Output;
    		.q_xOPN_DO	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E4 (EL2202)^Channel 2^Output;
    		.i_xClsLS	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E1 (EL1004)^Channel 1^Input;
    		.i_xOpnLS	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E1 (EL1004)^Channel 2^Input;
    		.i_xTrigger := 	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5_MKS937B (EL1124)^Channel 1^Input 
        '} 
    	
    	MR4K4_KBO_VFS_1 : FB_VFS;
    	*)
        
    	{attribute 'pytmc' :=' pv: MR4K4:KBO:VFS:01 '}
    	{attribute 'TcLinkTo' := 	'.q_e2OO3_MODE		:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_e2OO3_MODE;
    								 .q_xPRESS_OK_IG1	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xPress_OK_IG1;
    								 .q_xPRESS_OK_IG2	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xPress_OK_IG2;
    								 .q_xPRESS_OK_IG3	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xPress_OK_IG3;
    								 .q_xOPN_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xOPN_SW;
    								 .q_xCLS_SW			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xCLS_SW;
    								 .q_xVAC_FAULT_Reset := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xVAC_FAULT_Reset;
    								 .q_xOverrideMode	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xOverrideMode;
    								 .q_xOverrideOpen	:= 	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xOverrideOpen;
    								 .i_xTrigger		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_xTrigger;								                       
    								 .i_xVFS_Open		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_xVFS_Open;
    								 .i_xVFS_Closed		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_xVFS_Closed;
    								 .i_xVAC_FAULT_OK	:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_xVAC_FAULT_OK;
    								 .i_xMPS_OK			:=  TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_xMPS_OK;
    								 .i_eVFS_State		:=	TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_eVFS_State;
                                     .q_xVetoValveOpenDO := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xVetoValveOpenDO;
    								 .q_xVetoValveClosed := TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Inputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.i_xVetoValveClosed;
    								 .i_nFltCount_IG1	:= TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_nFltCount_IG1;
    								 .i_nFltCount_IG2	:= TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_nFltCount_IG2;
    								 .i_nFltCount_IG3	:= TIPC^PLC_TMO_VAC^PLC_TMO_VAC Instance^FSVTask Outputs^GVL_FS_Devices.MR4K4_KBO_VFS_1.q_nFltCount_IG3 '}
    	MR4K4_KBO_VFS_Interface : FB_VFS_2OO3Interface;

    	{attribute 'TcLinkTo' := 	'.q_xClose_A	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E3 (EL2202)^Channel 1^Output;
    								 .q_xClose_B	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E3 (EL2202)^Channel 2^Output;
    								 .q_xClose_C	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E4 (EL2202)^Channel 1^Output;
    								 .q_xOPN_DO		:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E4 (EL2202)^Channel 2^Output;
    								 .i_xClsLS		:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E1 (EL1004)^Channel 1^Input;
    								 .i_xOpnLS		:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E1 (EL1004)^Channel 2^Input;
    								 .i_xTriggerIG1	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5_MKS937B (EL1124)^Channel 1^Input;
    								 .i_xTriggerIG2	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5_MKS937B (EL1124)^Channel 2^Input;
    								 .i_xTriggerIG3	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E5A_MKS937B (EL1124)^Channel 1^Input '} 	
    	MR4K4_KBO_VFS_1 : FB_VFS_2OO3;

    END_VAR




GVL_FSV_PMPS
^^^^^^^^^^^^

::

    VAR_GLOBAL

    (*	
    	{attribute 'pytmc' := 'pv: TMO:VAC:FFO:03  '}
       {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[CX0_E1A (EL2202)]^Channel 1^Output'}
        g_FastFaultOutput3  :   FB_HardwareFFOutput;	//FFO for TV1K4-VFS-1
    	
        {attribute 'pytmc' := 'pv: TMO:VAC:FFO:04  '}
       {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[CX0_E1A (EL2202)]^Channel 2^Output'}
        g_FastFaultOutput4  :   FB_HardwareFFOutput;  // FF0 for MR3K4_KBO_VFS_01 & MR4K4_KBO_VFS_01
    	
    *)	
    END_VAR




GVL_Hutch_Gauges
^^^^^^^^^^^^^^^^

::

    //{attribute 'qualified_only'}
    VAR_GLOBAL
    (* Pirani & Cold Cathode*)

    	{attribute 'pytmc' :=' pv: MR2K4:KBO:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E1 (EL3174)^AI Standard Channel 2^Value '}
    	MR2K4_KBO_GPI_01 : FB_MKS275;
    	
    	{attribute 'pytmc' :=' pv: MR2K4:KBO:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E1 (EL3174)^AI Standard Channel 3^Value;
    								 .i_xHV_ON	    :=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E7 (EL1124)^Channel 3^Input;
    								 .i_xDisc_Active:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E7 (EL1124)^Channel 4^Input;								 
    								 .q_xHV_DIS		:= 	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E5 (EL2624)^Channel 2^Output	'}	
    	MR2K4_KBO_GCC_01 : FB_MKS500;
    	
    	{attribute 'pytmc' :=' pv: PA1K4:IP1:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E2 (EL3174)^AI Standard Channel 1^Value '}	
    	PA1K4_IP1_GPI_01 : FB_MKS275;
    	

    	{attribute 'pytmc' :=' pv: PA1K4:IP1:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E1 (EL3174)^AI Standard Channel 4^Value;
    								 .i_xHV_ON	    :=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E8 (EL1124)^Channel 1^Input;
    								 .i_xDisc_Active:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E8 (EL1124)^Channel 2^Input;								 
    								 .q_xHV_DIS		:= 	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E5 (EL2624)^Channel 3^Output	'}		
    	PA1K4_IP1_GCC_01 : FB_MKS500;
    	
    (*
    	{attribute 'pytmc' :=' pv: IM4K4:PPM:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E2 (EL3174)^AI Standard Channel 2^Value;
    								 .i_xHV_ON	    :=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E8 (EL1124)^Channel 3^Input;
    								 .i_xDisc_Active:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E8 (EL1124)^Channel 4^Input;								 
    								 .q_xHV_DIS		:= 	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E5 (EL2624)^Channel 4^Output	'}			
    	IM4K4_PPM_GCC_01 : FB_MKS500;
    *)
        // replacing IM4K4_PPM_GCC_01 with CCM501
    	{attribute 'pytmc' :=' pv: IM4K4:PPM:GCC:01 '}
        {attribute 'TcLinkTo' := 	'.i_iPRESS_R		:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E2 (EL3174)^AI Standard Channel 2^Value;
    								 .i_xHV_ON			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E20A (EL1088)^Channel 1^Input;
    								 .q_xHV_DIS			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E5 (EL2624)^Channel 4^Output '}
        IM4K4_PPM_GCC_01 : FB_CCM501;

    	{attribute 'pytmc' :=' pv: LI2K4:IP1:GFS:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E1_MKS937B (EL3064)^AI Standard Channel 1^Value;
    								 .q_xHV_DIS		:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E3_MKS937B (EL2794)^Channel 1^Output '}
    	LI2K4_IP1_GFS_01 : FB_MKS422;
    	
    	{attribute 'pytmc' :=' pv: LI2K4:IP1:GFS:02 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E1_MKS937B (EL3064)^AI Standard Channel 2^Value;
    								 .q_xHV_DIS		:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E3_MKS937B (EL2794)^Channel 2^Output '}
    	LI2K4_IP1_GFS_02 : FB_MKS422;

    	{attribute 'pytmc' :=' pv: LI2K4:IP1:GFS:03 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E2_MKS937B (EL3064)^AI Standard Channel 1^Value;
    								 .q_xHV_DIS		:=	TIIB[B940_R20_EK0 (EK1100)]^R20_EK0_E3_MKS937B (EL2794)^Channel 3^Output '}
    	LI2K4_IP1_GFS_03 : FB_MKS422;
    	
    	
    	{attribute 'pytmc' :=' pv: TM1K4:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E15 (EL3174)^AI Standard Channel 1^Value;
    								 .i_xHV_ON	    :=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E20 (EL1124)^Channel 1^Input;
    								 .i_xDisc_Active:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E20 (EL1124)^Channel 2^Input;								 
    								 .q_xHV_DIS		:= 	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E14 (EL2624)^Channel 1^Output	'}		
    	TM1K4_GCC_01 : FB_MKS500;
    	
    	{attribute 'pytmc' :=' pv: IM5K4:PPM:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E15 (EL3174)^AI Standard Channel 2^Value;
    								 .i_xHV_ON	    :=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E20 (EL1124)^Channel 3^Input;
    								 .i_xDisc_Active:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E20 (EL1124)^Channel 4^Input;								 
    								 .q_xHV_DIS		:= 	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E14 (EL2624)^Channel 2^Output	'}		
    	IM5K4_PPM_GCC_01 : FB_MKS500;
    	
    	
    	{attribute 'pytmc' :=' pv: PA2K4:IP1:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E15 (EL3174)^AI Standard Channel 4^Value '}	
    	PA2K4_IP1_GPI_01 : FB_MKS275;
    	
    	{attribute 'pytmc' :=' pv: PA2K4:IP1:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E15 (EL3174)^AI Standard Channel 3^Value;
    								 .i_xHV_ON	    :=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E21 (EL1124)^Channel 1^Input;
    								 .i_xDisc_Active:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E21 (EL1124)^Channel 2^Input;								 
    								 .q_xHV_DIS		:= 	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E14 (EL2624)^Channel 3^Output	'}		
    	PA2K4_IP1_GCC_01 : FB_MKS500;


    	{attribute 'pytmc' :=' pv: MR4K4:KBO:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E18 (EL3174)^AI Standard Channel 1^Value '}		
    	MR4K4_KBO_GPI_01 : FB_MKS275;

    	{attribute 'pytmc' :=' pv: MR4K4:KBO:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E18 (EL3174)^AI Standard Channel 2^Value;
    								 .i_xHV_ON	    :=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E21 (EL1124)^Channel 3^Input;
    								 .i_xDisc_Active:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E21 (EL1124)^Channel 4^Input;								 
    								 .q_xHV_DIS		:= 	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E14 (EL2624)^Channel 4^Output	'}			
    	MR4K4_KBO_GCC_01 : FB_MKS500;
        // need to update for the gauge model, if it is MKS500
        {attribute 'pytmc' :=' pv: TM2K4:KBO:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E4 (EL3174)^AI Standard Channel 1^Value;
    								 .i_xHV_ON	    :=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E8 (EL1124)^Channel 1^Input;
    								 .i_xDisc_Active:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E8 (EL1124)^Channel 2^Input;								 
    								 .q_xHV_DIS		:= 	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E3 (EL2624)^Channel 1^Output'}			
    	TM2K4_KBO_GCC_01 : FB_MKS500;
    	
    	{attribute 'pytmc' :=' pv: TM2K4:KBO:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E4 (EL3174)^AI Standard Channel 3^Value '}		
    	TM2K4_KBO_GPI_01 : FB_MKS275;
       
    (* 
          // need to update for the gauge model, if it is MKS500
        {attribute 'pytmc' :=' pv: PF2K4:KBO:GCC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E4 (EL3174)^AI Standard Channel 2^Value;
    								 .i_xHV_ON	    :=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E8 (EL1124)^Channel 3^Input;
    								 .i_xDisc_Active:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E8 (EL1124)^Channel 4^Input;								 
    								 .q_xHV_DIS		:= 	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E3 (EL2624)^Channel 2^Output	'}			
    	PF2K4_WFS_GCC_01 : FB_MKS500;
    *)
        // adding PF2K4_WFS_GCC_01 which is CCM501 type
        {attribute 'pytmc' :=' pv: PF2K4:KBO:GCC:01 '}
        {attribute 'TcLinkTo' := 	'.i_iPRESS_R		:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E4 (EL3174)^AI Standard Channel 2^Value;
    								 .i_xHV_ON			:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E6A (EL1084)^Channel 1^Input;
    								 .q_xHV_DIS			:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E3 (EL2624)^Channel 2^Output	'}
        PF2K4_WFS_GCC_01 : FB_CCM501;
       
    (*  	
      // need to update for the gauge name and model 
          {attribute 'pytmc' :=' pv: IM6K4:KBO:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E4 (EL3174)^AI Standard Channel 3^Value '}		
    	IM6K4_PPM_GPI_01 : FB_MKS275;
    *)
    	
    (* Roughing gauges *)

    	{attribute 'pytmc' :=' pv: TMO:ROUGH1:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_WALL_WEST_EP01 (EP4374-0002)]^AI Inputs Channel 1^Value	'}	
    	TMO_ROUGH1_GPI_01 : FB_9XX;
    	
    	{attribute 'pytmc' :=' pv: TMO:ROUGH1:GPI:02 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S2_ EP1 (EP4374-0002)]^AI Inputs Channel 1^Value	'}	
    	TMO_ROUGH1_GPI_02 : FB_9XX;
    	
    	{attribute 'pytmc' :=' pv: TMO:ROUGH1:GPI:03 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S6_ EP1 (EP4374-0002)]^AI Inputs Channel 1^Value	'}		
    	TMO_ROUGH1_GPI_03 : FB_9XX;

    	{attribute 'pytmc' :=' pv: TMO:ROUGH2:GPI:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_WALL_WEST_EP01 (EP4374-0002)]^AI Inputs Channel 2^Value	'}	
    	TMO_ROUGH2_GPI_01 : FB_9XX;
    	
    	{attribute 'pytmc' :=' pv: TMO:ROUGH2:GPI:02 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS_R	:=	TIIB[TMO_K4S2_ EP1 (EP4374-0002)]^AI Inputs Channel 2^Value	'}	
    	TMO_ROUGH2_GPI_02 : FB_9XX;	
    	

    	
    	
    		

    END_VAR




GVL_Hutch_Pumps
^^^^^^^^^^^^^^^

::

    //{attribute 'qualified_only'}
    VAR_GLOBAL
    	
    	
    (* Ion pumps *)

    	{attribute 'pytmc' :=' pv: MR2K4:KBO:PIP:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS		:=	TIIB[CX0_E9_QPC2 (EL3064)]^AI Standard Channel 2^Value;
    								 .i_xSP_DI		:= 	TIIB[CX0_E10_QPC2 (EL1004)]^Channel 2^Input;
    								 .q_xHVEna_DO	:= 	TIIB[CX0_E11_QPC2 (EL2794)]^Channel 2^Output
    	'}

    	MR2K4_KBO_PIP_01 : FB_PIP_Gamma;
    	
    	
    	
    	//SIP PIP NexTORR Pump
    	{attribute 'pytmc' :=' pv: PA2K4:IP1:PIP:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS		:=	TIIB[R20_EK0_SIP (EL3174-0002)]^AI Standard Channel 1^Value;
    								 .i_xIP_ON		:= 	TIIB[R20_EK0_E5_MKS937B (EL1124)]^Channel 3^Input;
    								 .i_xError      :=  TIIB[R20_EK0_E5_MKS937B (EL1124)]^Channel 4^Input;
    								 .q_xHVEna_DO	:= 	TIIB[R20_EK0_E3_MKS937B (EL2794)]^Channel 4^Output
    	'}
    	PA2K4_IP1_PIP_01 : FB_PIP_SIP;

    	{attribute 'pytmc' :=' pv: MR4K4:KBO:PIP:01 '}
    	{attribute 'TcLinkTo' := 	'.i_iPRESS		:=	TIIB[CX0_E9_QPC2 (EL3064)]^AI Standard Channel 4^Value;
    								 .i_xSP_DI		:= 	TIIB[CX0_E10_QPC2 (EL1004)]^Channel 4^Input;
    								 .q_xHVEna_DO	:= 	TIIB[CX0_E11_QPC2 (EL2794)]^Channel 4^Output
    	'}	
    	MR4K4_KBO_PIP_01 : FB_PIP_Gamma;
    	

    	

    (* Granite 1 *)
    (* Pfeiffer Turbo Pumps TC110 *)

    	{attribute 'TcLinkTo' := 	'.i_xAtSpd			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E11 (EL1004)^Channel 2^Input;
    								 .i_xFaultNC		:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E11 (EL1004)^Channel 1^Input;
    								 .q_RunDO			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E12 (EL2794)^Channel 1^Output;
    								 .q_xReset 			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E12 (EL2794)^Channel 2^Output				 
    	'}
    	{attribute 'pytmc' := '
    		pv: PA1K4:IP1:PTM:01
    		io: io
    	'}
    	PA1K4_IP1_PTM_01 : FB_PTM_Pfeiffer;



    	{attribute 'TcLinkTo' := 	'.i_xAtSpd			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E11 (EL1004)^Channel 4^Input;
    								 .i_xFaultNC		:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E11 (EL1004)^Channel 3^Input;
    								 .q_RunDO			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E12 (EL2794)^Channel 3^Output;
    								 .q_xReset 			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E12 (EL2794)^Channel 4^Output				 
    	'}
    	{attribute 'pytmc' := '
    		pv: PA1K4:IP1:PTM:02
    		io: io
    	'}	
    	PA1K4_IP1_PTM_02 : FB_PTM_Pfeiffer;
    	
    	{attribute 'TcLinkTo' := 	'.i_xAtSpd			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E13 (EL1004)^Channel 2^Input;
    								 .i_xFaultNC		:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E13 (EL1004)^Channel 1^Input;
    								 .q_RunDO			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E14 (EL2794)^Channel 1^Output;
    								 .q_xReset 			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E14 (EL2794)^Channel 2^Output				 
    	'}
    	{attribute 'pytmc' := '
    		pv: PA1K4:IP1:PTM:03
    		io: io
    	'}	
    	PA1K4_IP1_PTM_03 : FB_PTM_Pfeiffer;
    	
    	// They share the same serial port
    	st_Pfeiffer_CTRL_PTM_01_02_03			: ARRAY[1..20] OF ST_PfeifferControl;
    	st_Pfeiffer_RBK_PTM_01_02_03			: ARRAY[1..20] OF ST_PfeifferStatus;
    	PA1K4_IP1_PTM_01_02_03_COM: FB_PFEIFFER_COM;

    (* Leybold Turbo Pumps Mag.drive is*)	

    	{attribute 'TcLinkTo' := 	'.i_xAtSpd			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E15 (EL1004)^Channel 2^Input;
    								 .i_xFaultNC		:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E15 (EL1004)^Channel 1^Input;
    								 .q_RunDO			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E16 (EL2794)^Channel 1^Output			 
    	'}
    	{attribute 'pytmc' := '
    		pv: IM4K4:PPM:PTM:01
    		io: io
    	'}
    	IM4K4_PPM_PTM_01 : FB_PTM_TurboDrive;
    	IM4K4_PPM_PTM_01_COM:FB_Oerlikon_TD20_COM;
    	
    	{attribute 'TcLinkTo' := 	'.i_xAtSpd			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E15 (EL1004)^Channel 4^Input;
    								 .i_xFaultNC		:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E15 (EL1004)^Channel 3^Input;
    								 .q_RunDO			:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E16 (EL2794)^Channel 2^Output			 
    	'}
    	{attribute 'pytmc' := '
    		pv: LI1K4:IP1:PTM:01
    		io: io
    	'}
    	LI1K4_IP1_PTM_01 : FB_PTM_TurboDrive;
    	LI1K4_IP1_PTM_01_COM: FB_Oerlikon_TD20_COM;

    (* Granite 2 *)
    (* Pfeiffer Turbo Pumps TM700 *)

    	{attribute 'TcLinkTo' := 	'.i_xAtSpd			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E6 (EL1004)^Channel 1^Input;
    								 .i_xRemote			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E6 (EL1004)^Channel 2^Input;
    								 .i_xFaultNC		:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E6 (EL1004)^Channel 3^Input;
    								 .q_RunDO			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E7 (EL2004)^Channel 1^Output;
    								 .q_xRemote			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E7 (EL2004)^Channel 2^Output;
    								 .q_PumpingStation	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E7 (EL2004)^Channel 3^Output				 
    	'}
    	{attribute 'pytmc' := '
    		pv: LI3K4:IP1:OUT:PTM:01
    		io: io
    	'}
        LI3K4_IP1_OUT_PTM_01 : FB_PTM_Pfeiffer;
    (* Pfeiffer Turbo Pumps TC400 *)
    	
    	{attribute 'TcLinkTo' := 	'.i_xAtSpd			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E6 (EL1004)^Channel 4^Input;
    								 .i_xRemote			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E8 (EL1004)^Channel 1^Input;
    								 .i_xFaultNC		:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E8 (EL1004)^Channel 2^Input;					 
    								 .q_RunDO			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E7 (EL2004)^Channel 4^Output;
    								 .q_xRemote			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E9 (EL2004)^Channel 1^Output;
    								 .q_PumpingStation	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E9 (EL2004)^Channel 2^Output				 
    	'}
    	{attribute 'pytmc' := '
    		pv: TM1K4:PTM:01
    		io: io
    	'}
    	TM1K4_PTM_01 : FB_PTM_Pfeiffer;
    	
    	
    	{attribute 'TcLinkTo' := 	'.i_xAtSpd			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E8 (EL1004)^Channel 3^Input;
    								 .i_xRemote			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E8 (EL1004)^Channel 4^Input;
    								 .i_xFaultNC		:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E11 (EL1004)^Channel 1^Input;
    								 .q_RunDO			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E9 (EL2004)^Channel 3^Output;
    								 .q_xRemote			:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E9 (EL2004)^Channel 4^Output;
    								 .q_PumpingStation	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E12 (EL2004)^Channel 1^Output				 
    	'}
    	{attribute 'pytmc' := '
    		pv: IM5K4:PPM:PTM:01
    		io: io
    	'}
    	IM5K4_PPM_PTM_01 : FB_PTM_Pfeiffer;
    	// They share the same serial port
    	st_Pfeiffer_CTRL_PTM_Granite2			: ARRAY[1..20] OF ST_PfeifferControl;
    	st_Pfeiffer_RBK_PTM_Granite2			: ARRAY[1..20] OF ST_PfeifferStatus;
    	Granite2_PTM_COM :FB_PFEIFFER_COM;
    	
    END_VAR




GVL_Hutch_Valves
^^^^^^^^^^^^^^^^

::

    //{attribute 'qualified_only'}
    VAR_GLOBAL
    	
    (*  Beamline Windows Valve *)

    	{attribute 'pytmc' :=' pv: MR2K4:KBO:VWC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[TMO_K4S2_DRL_01 (EK1100)]^K4S2_01_E5 (EL1004)^Channel 1^Input;
    								 .i_xClsLS	:=	TIIB[TMO_K4S2_DRL_01 (EK1100)]^K4S2_01_E5 (EL1004)^Channel 2^Input;
    								.q_xOPN_DO	:=	TIIB[TMO_K4S2_DRL_01 (EK1100)]^K4S2_01_E6 (EL2004)^Channel 1^Output'}
    	MR2K4_KBO_VWC_01 : FB_VGC_2S;
    	
    	
    	{attribute 'pytmc' :=' pv: MR3K4:KBO:VWC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[TMO_K4S2_DRL_01 (EK1100)]^K4S2_01_E5 (EL1004)^Channel 3^Input;
    								 .i_xClsLS	:=	TIIB[TMO_K4S2_DRL_01 (EK1100)]^K4S2_01_E5 (EL1004)^Channel 4^Input;
    								.q_xOPN_DO	:=	TIIB[TMO_K4S2_DRL_01 (EK1100)]^K4S2_01_E6 (EL2004)^Channel 2^Output'}	
    	MR3K4_KBO_VWC_01 : FB_VGC_2S;
    	
    	
    	{attribute 'pytmc' :=' pv: LI3K4:IP1:VWC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E3 (EL1004)^Channel 1^Input;
    								 .i_xClsLS	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E3 (EL1004)^Channel 2^Input;
    								.q_xOPN_DO	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E4 (EL2004)^Channel 1^Output'}		
    	LI3K4_IP1_VWC_01 : FB_VGC_2S;
    	
    	{attribute 'pytmc' :=' pv: PC5K4:VWC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E3 (EL1004)^Channel 3^Input;
    								 .i_xClsLS	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E3 (EL1004)^Channel 4^Input;
    								.q_xOPN_DO	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E4 (EL2004)^Channel 2^Output'}		
    	PC5K4_VWC_01 : FB_VGC_2S;


    	{attribute 'pytmc' :=' pv: MR4K4:KBO:VWC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E5 (EL1004)^Channel 1^Input;
    								 .i_xClsLS	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E5 (EL1004)^Channel 2^Input;
    								.q_xOPN_DO	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E6 (EL2004)^Channel 1^Output'}		
    	MR4K4_KBO_VWC_01 : FB_VGC_2S;
    	
    	
    	{attribute 'pytmc' :=' pv: MR5K4:KBO:VWC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E5 (EL1004)^Channel 3^Input;
    								 .i_xClsLS	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E5 (EL1004)^Channel 4^Input;
    								.q_xOPN_DO	:=	TIIB[TMO_K4S8_DRL_01 (EK1100)]^K4S8_01_E6 (EL2004)^Channel 2^Output'}		
    	MR5K4_KBO_VWC_01 : FB_VGC_2S;
    	
        {attribute 'pytmc' :=' pv: TM2K4:KBO:VWC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E1 (EL1004)^Channel 1^Input;
    								 .i_xClsLS	:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E1 (EL1004)^Channel 2^Input;
    								.q_xOPN_DO	:=	TIIB[TMO_K4S8_DRL_02 (EK1100)]^K4S8_02_E2 (EL2004)^Channel 1^Output'}		
    	TM2K4_KBO_VWC_01 : FB_VGC_2S;
       
    	
    	   
    	
    	
    (*  Roughing valve *)	

    	{attribute 'pytmc' :=' pv: TMO:ROUGH1:VRC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E19 (EL1004)^Channel 1^Input;
    								 .i_xClsLS	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E19 (EL1004)^Channel 2^Input;
    								.q_xOPN_DO	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E20 (EL2004)^Channel 1^Output'}
    	TMO_ROUGH1_VRC_01 : FB_VGC_2S;

    	{attribute 'pytmc' :=' pv: TMO:ROUGH1:VRC:02 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E1 (EL1004)^Channel 1^Input;
    								 .i_xClsLS	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E1 (EL1004)^Channel 2^Input;
    								.q_xOPN_DO	:=	TIIB[TMO_K4S6_DRL_01 (EK1100)]^K4S6_01_E2 (EL2004)^Channel 1^Output'}
    	TMO_ROUGH1_VRC_02 : FB_VGC_2S;
    	
    	{attribute 'pytmc' :=' pv: TMO:ROUGH2:VRC:01 '}
    	{attribute 'TcLinkTo' := 	'.i_xOpnLS	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E19 (EL1004)^Channel 3^Input;
    								 .i_xClsLS	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E19 (EL1004)^Channel 4^Input;
    								.q_xOPN_DO	:=	TIIB[TMO_K4S2_DRL_02 (EK1100)]^K4S2_02_E20 (EL2004)^Channel 2^Output'}
    	TMO_ROUGH2_VRC_01 : FB_VGC_2S;

    (* MKS248 with MKS1249 solenoid driver *)

    	{attribute 'pytmc' :=' pv: TMO:ROUGH1:VFV:01 '}
    	{attribute 'TcLinkTo' := 	'.q_iRawPosition	:=	TIIB[TMO_WALL_WEST_EP01 (EP4374-0002)]^AO Outputs Channel 3^Analog output	'}	
         TMO_ROUGH1_VFV_01 : FB_MKS248;
    	 
    	{attribute 'pytmc' :=' pv: TMO:ROUGH1:VFV:02 '}
    	{attribute 'TcLinkTo' := 	'.q_iRawPosition	:=	TIIB[TMO_K4S2_ EP1 (EP4374-0002)]^AO Outputs Channel 3^Analog output	'}	
    	 TMO_ROUGH1_VFV_02 : FB_MKS248;
    	 
    	{attribute 'pytmc' :=' pv: TMO:ROUGH1:VFV:03 '}
    	{attribute 'TcLinkTo' := 	'.q_iRawPosition	:=	TIIB[TMO_K4S6_ EP1 (EP4374-0002)]^AO Outputs Channel 3^Analog output	'}		 
    	 TMO_ROUGH1_VFV_03 : FB_MKS248;
    	 
    	{attribute 'pytmc' :=' pv: TMO:ROUGH2:VFV:01 '}
    	{attribute 'TcLinkTo' := 	'.q_iRawPosition	:=	TIIB[TMO_K4S2_ EP1 (EP4374-0002)]^AO Outputs Channel 4^Analog output	'}		 
    	 TMO_ROUGH2_VFV_01 : FB_MKS248;
    	 
    	

    	
    	
    END_VAR




GVL_IP1_ECAT
^^^^^^^^^^^^

::

    //{attribute 'qualified_only'}
    VAR_GLOBAL
    	
    	(* These variables are for IP1 EtherCat bridge *)
    	
    	(*ETHERCAT BRIDGE COM STATUS*)
    	//EL6692 TxPDO state
    	//0: Other side is in OP state, >0: Error
    	{attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^SYNC Inputs^TxPDO state			 
    	'}
    	xEcatBridge_TxPDO_state AT %I* : BOOL;
    	
    	//0: External device connected, 1: External device not connected
    	{attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^SYNC Inputs^External device not connected			 
    	'}
    	xEcatBridge_External_device_not_connected AT %I* : BOOL;
    	
    	//0 = Data valid, 1 = Data invalid
    	{attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^WcState^WcState			 
    	'}
    	xEcatBridge_WcState AT %I* : BOOL;
    	
    	
     {attribute 'pytmc' := 'pv: TMO:IP1:ENDSTATION:ETHERCAT_ERROR'}	
      IP1_ECAT_COM_ERROR AT %I* : BOOL;
    	
    	//EL6692 Output 
    		
      {attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Outputs^HUTCH_PLC_NAME			 
    	'}
       My_PLC_NAME	AT %Q*	: STRING(8) := 'TMO';
       
        {attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Outputs^TMO_ROUGH1_VRC_01_OPEN_LS			 
    	'}  
       ROUGH1_VRC_01_AtOpnLS AT %Q* : BOOL := FALSE;
       
        {attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Outputs^TMO_ROUGH2_VRC_01_OPEN_LS			 
    	'} 
       ROUGH2_VRC_01_AtOpnLS AT %Q* : BOOL := FALSE;
       
       	//EL6692 Input 
       {attribute 'pytmc' :=' pv: TMO:IP1:PLC:NAME '}
       {attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^ENDSTATION_PLC_NAME			 
    	'}
       IP1_PLC_NAME AT %I*  : STRING(8);
       
       {attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_ROUGH_VRC_01_OPEN_LS			 
    	'} 
       IP1_ROUGH_VRC_01_AtOpnLS AT %I* : BOOL;
       
         {attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_ROUGH_VRC_02_OPEN_LS			 
    	'} 
       IP1_ROUGH_VRC_02_AtOpnLS AT %I* : BOOL;
       
         {attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_ROUGH_VRC_03_OPEN_LS			 
    	'} 
       IP1_ROUGH_VRC_03_AtOpnLS AT %I* : BOOL;
       
        {attribute 'pytmc' :=' pv: TMO:IP1:TURBOS:ALL_AT_SPD'}
    	{attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_TURBOS_ALL_AtSpd			 
    	'} 
       IP1_TURBOS_ALL_AtSpd AT %I* : BOOL;
       
       {attribute 'pytmc' :=' pv: TMO:IP1:HV_SAFETY_ENABLE'}
    	{attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_HV_SAFETY_ENABLE			 
    	'} 
       IP1_HV_SAFETY_ENABLE AT %I* : BOOL;
       
     (*    {attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_MAIN_xAT_VAC			 
    	'} 
       IP1_Main_xAT_VAC AT %I* : BOOL;
       
            {attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_MAIN_xPRESS_OK			 
    	'} 
       IP1_Main_xPRESS_OK AT %I* : BOOL;
       
            {attribute 'TcLinkTo' := 	'TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_MAIN_rPRESS			 
    	'} 
       IP1_Main_rPRESS AT %I* : REAL;
      *)
     
       {attribute 'pytmc' :=' pv: TMO:IP1:MAIN:GAUGE'}
       {attribute 'TcLinkTo' := 	'.i_xAT_VAC				:=	TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_MAIN_xAT_VAC;
    					         .i_xPRESS_OK			:=	TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_MAIN_xPRESS_OK;
    							 .i_rPRESS			    :=	TIIB[CX0_E13 (EK1122)]^IP1_ECAT (EL6692)^IO Inputs^IP1_MAIN_rPRESS		 
    	'}	
    	IP1_MAIN_GAUGE : FB_Gauge_Interface;
    	
    END_VAR


Related:
    * `MAIN`_


GVL_PMPS
^^^^^^^^

::

    //{attribute 'qualified_only'}
    VAR_GLOBAL
    	
    //Example implementation of the FFO
        {attribute 'pytmc' := 'pv: PLC:TMO:VAC:FFO:01    '}
        {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[CX0_E1 (EL2202)]^Channel 1^Output'}
        g_FastFaultOutput1  :   FB_HardwareFFOutput:=(i_sNetID:='172.21.42.126.1.1');	//FFO for ST3K4_PPS's Upstream Components
    	
    	 {attribute 'pytmc' := 'pv: PLC:TMO:VAC:FFO:02  '}
        {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[CX0_E1 (EL2202)]^Channel 2^Output'}
        g_FastFaultOutput2  :   FB_HardwareFFOutput:=(i_sNetID:='172.21.42.126.1.1');	//FFO for ST3K4_PPS's Downstream Components
    	
       {attribute 'pytmc' := 'pv: PLC:TMO:VAC:FFO:03  '}
       {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[CX0_E1A (EL2202)]^Channel 1^Output'}
        g_FastFaultOutput3  :   FB_HardwareFFOutput;	//FFO for TV1K4-VFS-1
    	
        {attribute 'pytmc' := 'pv: PLC:TMO:VAC:FFO:04  '}
       {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[CX0_E1A (EL2202)]^Channel 2^Output'}
        g_FastFaultOutput4  :   FB_HardwareFFOutput;  // FF0 for MR3K4_KBO_VFS_01 & MR4K4_KBO_VFS_01 
    	
         {attribute 'pytmc' := 'pv: PLC:TMO:VAC:FFO:05  '}
    	
    	g_FastFaultOutput5 :    FB_HardwareFFOutput;  // FFO for ST4K4 photo terminator downstream devices
    	
          {attribute 'pytmc' := 'pv: PLC:TMO:VAC:FFO:06  '}
        g_FastFaultOutput6 :    FB_HardwareFFOutput;  // FFO for ST4K4 photo terminator downstream MR4K4_KBO_VFS_01 device
    	
    	{attribute 'pytmc' := '    pv: PLC:TMO:VAC:RESET:FF1    '}
    	xReset_PMPS_FFO1	:	BOOL	:=	FALSE;		//FFO RESET for ST3K4_PPS's Upstream Components
    	{attribute 'pytmc' := '    pv: PLC:TMO:VAC:RESET:FF2  '}
    	xReset_PMPS_FFO2	:	BOOL	:=	FALSE;		//FFO RESET for ST3K4_PPS's Downstream Components
    	{attribute 'pytmc' := '    pv: PLC:TMO:VAC:RESET:FF5  '}
    	xReset_PMPS_FFO5	:	BOOL	:=	FALSE;		//FFO RESET for ST4K4_PPS's Downstream Components
    	
    	{attribute 'pytmc' := '        pv: PLC:TMO:VAC:ARB:01    '}
        g_fbArbiter1    :   FB_Arbiter(1); //Veto group downstream of MR1K1
    	{attribute 'pytmc' := '        pv: PLC:TMO:VAC:ARB:02    '}
    	g_fbArbiter2     :  FB_Arbiter(2); //Veto group downstream of ST3K4
    	{attribute 'pytmc' := '        pv: PLC:TMO:VAC:ARB:03    '}
    	g_fbArbiter3     :  FB_Arbiter(3); //Veto group downstream of ST4K4
    	
    	xTMO_FEE_MPS_OK: BOOL := TRUE;
    	
    	xTMO_NEH_MPS_OK: BOOL := TRUE;

    END_VAR




GVL_Variables
^^^^^^^^^^^^^

::

    //{attribute 'qualified_only'}
    VAR_GLOBAL
    	

    //	r_Accelerator_Setpoint	: REAL := 1E-12; (*unrealistic setpoint currently*)
    	{attribute 'pytmc' := 'pv: TMO:FEE:VAC:OVRDON'}
    	xSystemOverrideMode_FEE	: BOOL := FALSE; (* Global system override for the TMO FEE Vacuum System *)
    	
    	{attribute 'pytmc' := 'pv: TMO:NEH:VAC:OVRDON'}
    	xSystemOverrideMode_TMO	: BOOL := FALSE; (* Global system override for the TMO hutch Vacuum System *)
    	
    	{attribute 'pytmc' := 'pv: TMO:NEH:TURBO:FAULT'}
    	xTurboFault: BOOL := FALSE; (* True if any hutch turbo is not at speed or fault *)	
    	
    	{attribute 'pytmc' := 'pv: TMO:NEH:VALVE:FAULT'}
    	xBeamlineValveFault: BOOL := FALSE; (* True if any beamline valve is not open OK *)	
    	
    		{attribute 'pytmc' := 'pv: TMO:NEH:ALL:GCC:ENABLE'}
    	xGCC_Enable_SW: BOOL := FALSE; (* True if any hutch turbo is not at speed or fault *)

    	{attribute 'pytmc' := 'pv: TMO:LAMP:PTM_NOK'}
    	
    	xLAMP_PTM_NOK AT%I*: BOOL := FALSE; (* True if any hutch turbo is not at speed or fault *)

    	{attribute 'pytmc' := 'pv: TMO:VRC:DIFPRESS:BYPASS'}
    	xBypassDiffPress_vrc1_vrc2 : BOOL;

    	{attribute 'pytmc' := 'pv: TMO:FIM:HV_LOOP_PRESS'}
    	iHV_LOOP_FIM_PRESSURE: REAL:= 8e-9;	//As Peter's request
    	
    	{attribute 'pytmc' := 'pv: TMO:FIM:HV_LOOP_ON'}
    	{attribute 'TcLinkTo' := 'TIIB[K4S2_02_E20 (EL2004)]^Channel 4^Output'}
    	iHV_LOOP_FIM_ON	AT %Q*: BOOL:= FALSE;	
    	

    	
    END_VAR




POUs
----


DIAGNOSTICS
^^^^^^^^^^^

::

    PROGRAM DIAGNOSTICS
    VAR
    	//Change the PLC String Name to the actual PLC NAME
    	sPLCName :STRING := 'PLC-TMO-VAC';
    	//Link the sAMSNetID to the Etherat Master netID
    	i_sAMSNetID AT %I*: AMSNETID;
    	// DO NOT CHANGE
    	sAMSNetID : STRING; //used for EPICS PV
    	sLibVersion_LCLS_General : STRING;(* := stLibVersion_LCLS_General.sVersion*) ;
    	
    	fbEcatDiag:FB_EcatDiag;
    	{attribute 'pytmc' := ' pv:PLC:TMO:VAC:AllSlaveStateGood '}
    	bAllSlaveStateGood : BOOL;
    	{attribute 'pytmc' := ' pv:PLC:TMO:VAC:MasterStateGood '}	
    	bMasterStateGood :BOOL;
    	iMasterState: WORD;
    	sMasterState:STRING;
    	nSlaveNumber : UINT;
    	aiSlaveStates: ARRAY[1..256] OF BYTE;
    	aEcSlaveInfo :  ARRAY[1..256] OF ST_EcDevice;
    END_VAR
    // Instaniating a call to the fbEcatDiag
    fbEcatDiag(
    	I_AMSNetId:=i_sAMSNetID , 
    	i_xFirstPass:= _TaskInfo[1].FirstCycle, 
    	q_xAllSlaveStatesGood=> bAllSlaveStateGood , 
    	q_anTermStates=> aiSlaveStates, 
    	q_xMasterStateGood=>bMasterStateGood , 
    	q_nMasterState=> iMasterState, 
    	q_sMasterState=> sMasterState , 
    	q_astEcConfSlaveInfo=> aEcSlaveInfo , 
    	q_nSlaves=> nSlaveNumber);

    END_PROGRAM




F_Turbo_Protection_ILK
^^^^^^^^^^^^^^^^^^^^^^

::

    FUNCTION F_Turbo_Protection_ILK : BOOL
    VAR_INPUT
    	i_stTurbo : ST_PTM; // Turbo Pump
    	i_stISG : ST_VG; //Gauge measuring inlet Pressure e.g Pirani
    	i_stBSG : ST_VG; //Gauge measureing backing pressure
    	iq_stValve : ST_VGC_2S; //
    	
    	

    END_VAR
    VAR
    	
    END_VAR
    (* Allow turbo to run when gauges on both side are reading pressure below than SP and backing line valve is OPN *)

    						
    F_Turbo_Protection_ILK := (i_stISG.xPRESS_OK AND i_stISG.rPRESS < i_stTurbo.rInletPressureSP) AND 
    						   (i_stBSG.xPRESS_OK AND i_stBSG.rPRESS < i_stTurbo.rBackingPressureSP)AND 
    							iq_stValve.i_xOpnLS;

    END_FUNCTION




FB_VRC_NO_FFO_VLS
^^^^^^^^^^^^^^^^^

::

    FUNCTION_BLOCK FB_VRC_NO_FFO_VLS EXTENDS FB_VRC_NO
    VAR_IN_OUT
    	io_fbFFHWO    :    FB_HardwareFFOutput;
    	fbArbiter: FB_Arbiter();
    END_VAR
    VAR_INPUT
    	i_xPMPS_OK:	BOOL	; (*Set to True To switch off the bptm and PMPS Arbiter*)
    	i_xIsAperture:BOOL :=FALSE; // Set tp True if this is an Aperture Valve, the MPS Fault will trip only when moving.
    	i_sDevName : T_MaxString :=  'VGC'; // Device name for diagnostic
    	i_nTransitionRootID: UDINT; //A unique transition Root ID that is equal to or greater than 1000i_xIsAperture:BOOL :=FALSE; // Set tp True if this is an Aperture Valve, the MPS Fault will trip only when moving.
    END_VAR
    VAR_OUTPUT
    	
    END_VAR
    VAR

    	xPMPS_OK:	BOOL	; (*PMPS interlock*)
    	bMoving : BOOL;
    	bDone :BOOL;
    	tBPTMtimeout:TON;
    	bptm: BeamParameterTransitionManager;  
    	FFO    :    FB_FastFault :=(
            i_DevName := 'VGC',
            i_Desc := 'Fault occurs when the valve is not in safe state',
            i_TypeCode := 16#1010);
    	xMPS_OK:	BOOL; (*MPS Fast OK, is set when the Valve is Open*)

    END_VAR
    (*IO Mapping*)
    ACT_IO();

    (* On first PLC pass, put valve into vented state, which implies a closed valve *)
    IF xFirstPass THEN
    	iq_stValve.eVGC_State := Vented;
    	iq_stValve.pv_xCLS_SW := FALSE;
    	FFO.i_DevName := i_sDevName;
    //	iq_stValve.sDevName := i_sDevName;
    END_IF


    ///Check valve position
    IF iq_stValve.i_xClsLS AND  iq_stValve.i_xOpnLS THEN
    	iq_stValve.eState:=INVALID;
    ELSIF NOT iq_stValve.i_xOpnLS AND iq_stValve.i_xClsLS AND iq_stValve. THEN 
    	iq_stValve.eState:=CLOSED;
    ELSIF NOT iq_stValve.i_xClsLS AND iq_stValve.i_xOpnLS AND NOT iq_stValve.q_xOPN_DO THEN 
    	iq_stValve.eState:=OPEN_F;
    ELSIF iq_stValve.i_xClsLS AND NOT iq_stValve.i_xOpnLS AND NOT iq_stValve.q_xOPN_DO THEN 
    	iq_stValve.eState:=CLOSED;
    ELSIF NOT iq_stValve.i_xClsLS AND NOT iq_stValve.i_xOpnLS THEN 
    	iq_stValve.eState:=MOVING;
    ELSE
    	iq_stValve.eState:=INVALID;
    END_IF




    (*PMPS*)
    IF NOT(i_xPMPS_OK) THEN
    	ACT_PMPS();
    END_IF
    (*when interlock is lost the Valve closes regardless of the status of the PMPS and EPS*)
    xPMPS_OK := i_xPMPS_OK OR (bptm.q_xTransitionAuthorized OR tBPTMtimeout.Q);
    IF NOT (iq_stValve.xOPN_OK) THEN
    	iq_stValve.pv_xOPN_SW:= FALSE; // Reset switch after inlk is lost
    	iq_stValve.q_xOPN_DO := (iq_stValve.pv_xOPN_SW  AND iq_stValve.xOPN_OK) OR (tonOvrd.Q AND i_xOverrideMode);
    ELSIF xPMPS_OK THEN 
    	iq_stValve.q_xOPN_DO := (iq_stValve.pv_xOPN_SW  AND iq_stValve.xOPN_OK) OR (tonOvrd.Q AND i_xOverrideMode);
    //ELSIF NOT (i_xPMPS_OK) THEN
    	// Only override mode
    	//iq_stValve.q_xOPN_DO := (tonOvrd.Q AND i_xOverrideMode);
    END_IF

    (*MPS Fault setting*)
    If (i_xIsAperture ) THEN 
    	(* When the valve  is open or in Closed position MPS is OK, Fault while moving*)
    	xMPS_OK := (i_xOpnLS  AND NOT q_xCLS_DO) XOR (i_xClsLS  AND q_xCLS_DO); 
    ELSE
    	(* When the valve  is open MPS is OK*)
    	xMPS_OK := i_xOpnLS AND NOT i_xClsLS AND q_xCLS_DO; 
    END_IF

    (*FAST FAULT*)
    FFO(i_xOK := xMPS_OK,
        i_xReset := ,
    	i_xAutoReset :=TRUE,
        io_fbFFHWO := io_fbFFHWO);

    END_FUNCTION_BLOCK

    ACTION ACT_IO:
    (*inputs*)
    iq_stValve.i_xOpnLS := 	i_xOpnLS;
    iq_stValve.i_xClsLS:=	i_xClsLS;
    //iq_stValve. := i_xEXT_OK;
    iq_stValve.xOverrideMode := i_xOverrideMode;
    (*outputs*)
    //q_xOPN_DO:= iq_stValve.q_xOPN_DO;
    END_ACTION

    ACTION ACT_PMPS:
    bMoving := (iq_stValve.pv_xOPN_SW AND iq_stValve.i_xClsLS) XOR (NOT iq_stValve.pv_xOPN_SW AND i_xOpnLS);
    bDone := (iq_stValve.pv_xOPN_SW AND iq_stValve.i_xOpnLS) XOR (NOT iq_stValve.pv_xOPN_SW AND i_xClsLS);
    If (i_xIsAperture ) OR (iq_stValve.pv_xOPN_SW )THEN
    	bptm.i_stRequestedAssertion := PMPS_GVL.cstFullBeam;
    ELSE  bptm.i_stRequestedAssertion := PMPS_GVL.cst0RateBeam;
    END_IF
    bptm(fbArbiter:=fbArbiter,
         i_TransitionAssertionID:=i_nTransitionRootID+2,
         i_stTransitionAssertion:=PMPS_GVL.cst0RateBeam,
         i_nRequestedAssertionID:=i_nTransitionRootID+ BOOL_TO_UDINT( iq_stValve.pv_xOPN_SW),
         i_stRequestedAssertion:=,
         i_xMoving:=bMoving,
         i_xDoneMoving:= bDone,
         stCurrentBeamParameters:=PMPS_GVL.stCurrentBeamParameters,
         q_xTransitionAuthorized=>);
    // Timeout
    tBPTMtimeout(IN:= bMoving AND NOT bptm.q_xTransitionAuthorized , PT:=T#1S);
    //xPMPS_OK := bptm.q_xTransitionAuthorized OR tBPTMtimeout.Q;

    //Timeout and clear request
    IF (tBPTMtimeout.Q) THEN
    	fbArbiter.RemoveRequest(bptm.i_TransitionAssertionID);
    	fbArbiter.RemoveRequest(bptm.i_nRequestedAssertionID);
    END_IF
    END_ACTION

    METHOD PUBLIC M_IsClosed : BOOL
    VAR_INPUT
    END_VAR
    M_IsClosed := (This^.iq_stValve.eState = E_ValvePositionState.CLOSED);
    END_METHOD

    METHOD PUBLIC M_IsOpen : BOOL
    VAR_INPUT
    END_VAR
    M_IsOpen := (This^.iq_stValve.eState = E_ValvePositionState.OPEN);
    END_METHOD

    // Use this Methode to Open or close the valve by setting the OPN_SW to the input value.
    METHOD PUBLIC M_Set_CLS_SW : BOOL
    VAR_INPUT
    		value:BOOL;
    END_VAR
    This^.iq_stValve.pv_xCLS_SW := value;
    END_METHOD




MAIN
^^^^

::

    PROGRAM MAIN
    VAR

    	fbLogHandler : FB_LogHandler;
    	
    END_VAR
    fbLogHandler();

    (* FEE devices*)
    PRG_FEE();
    PRG_PMPS();
    PRG_FSV_Interfaces();

    (*  *)

    (*Hutch*)
    PRG_Hutch_Gauges();
    PRG_Hutch_Beamline_Valves();
    PRG_Roughing_Pumps();
    PRG_Hutch_Ion_Pumps();

    PRG_IP1_ECAT_Interfaces();
    PRG_HV_SAFETY();

    END_PROGRAM


Related:
    * `PRG_FEE`_
    * `PRG_FSV_Interfaces`_
    * `PRG_HV_SAFETY`_
    * `PRG_Hutch_Beamline_Valves`_
    * `PRG_Hutch_Gauges`_
    * `PRG_Hutch_Ion_Pumps`_
    * `PRG_IP1_ECAT_Interfaces`_
    * `PRG_PMPS`_
    * `PRG_Roughing_Pumps`_


PRG_COM
^^^^^^^

::

    PROGRAM PRG_COM
    VAR
    END_VAR
    //needs to run on a seperate task

    (*Instanitate Serial port com function *) 
    //PA1K4_IP1_PTM_01 , 02 and 03 
    K4S2_02_E10_fbSerialLineControl(
    	Mode:= SERIALLINEMODE_EL6_22B,
    	pComIn:= ADR(K4S2_02_E10_stComIn),
    	pComOut:=ADR(K4S2_02_E10_stComOut),
    	SizeComIn:= SIZEOF(K4S2_02_E10_stComOut),
    	TxBuffer:= K4S2_02_E10_SerialTXBuffer,
    	RxBuffer:= K4S2_02_E10_SerialRXBuffer,
    	Error=> ,
    	ErrorID=> );
    	

    //Granite 2
    	//LI3K4_IP1_OUT_PTM_01-TM1K4_PTM_01-IM5K4_PPM_PTM_01
    	//K4S6_01_E5 (EL6021)
    (*Instanitate Serial port com function *) 
    K4S6_01_E5_fbSerialLineControl(
    	Mode:= SERIALLINEMODE_EL6_22B,
    	pComIn:= ADR(K4S6_01_E5_stComIn),
    	pComOut:=ADR(K4S6_01_E5_stComOut),
    	SizeComIn:= SIZEOF(K4S6_01_E5_stComIn),
    	TxBuffer:= K4S6_01_E5_SerialTXBuffer,
    	RxBuffer:= K4S6_01_E5_SerialRXBuffer,
    	Error=> ,
    	ErrorID=> );

    //IM4K4_PPM_PTM_01
    	//K4S2_02_E17 (EL6001)
    	(*Instanitate Serial port com function *) 
    K4S2_02_E17_fbSerialLineControl(
    	Mode:= SERIALLINEMODE_EL6_22B,
    	pComIn:= ADR(K4S2_02_E17_stComIn),
    	pComOut:=ADR(K4S2_02_E17_stComOut),
    	SizeComIn:= SIZEOF(K4S2_02_E17_stComIn),
    	TxBuffer:= K4S2_02_E17_SerialTXBuffer,
    	RxBuffer:= K4S2_02_E17_SerialRXBuffer,
    	Error=> ,
    	ErrorID=> );
    	
    //LI1K4_IP1_PTM_01
    	//K4S2_02_E18 (EL6001)
    (*Instanitate Serial port com function *) 
    K4S2_02_E18_fbSerialLineControl(
    	Mode:= SERIALLINEMODE_EL6_22B,
    	pComIn:= ADR(K4S2_02_E18_stComIn),
    	pComOut:=ADR(K4S2_02_E18_stComOut),
    	SizeComIn:= SIZEOF(K4S2_02_E18_stComIn),
    	TxBuffer:= K4S2_02_E18_SerialTXBuffer,
    	RxBuffer:= K4S2_02_E18_SerialRXBuffer,
    	Error=> ,
    	ErrorID=> );

    END_PROGRAM




PRG_FEE
^^^^^^^

::

    PROGRAM PRG_FEE
    VAR
    ADS_connection_counter : UDINT;	

    (*Upstream Interface*)
    	
        USG_PIP : ST_VG;
    	
    	USG_VGC : ST_VG;
    	


    END_VAR
    (* Gauges*)
       (* Read GCC from upstream PLC - plc-kfe-vac*)
      (* MR1K4_GCC_01_ADS(
    	sNetId:= '172.21.92.61.1.1', 
    	nPort:=851 , 
    	sVarName:= 'fb_MR1K4_SOMS_GCC_1' , 
    	iWatchdog:=ADS_connection_counter , 
    	IG=> , 
    	bError=> ); *)
    	(* if upstream vacuum ok, set upstream press at good levels *)  
        IF USVacOk_LO THEN 
    		USG_VGC.xAT_VAC := TRUE;
    		USG_VGC.rPRESS := 1E-7;
    		USG_VGC.xPRESS_OK := TRUE;
    		USG_VGC.sPath:=  'MR1K4_SOMS_GCC_1';
    	ELSE
    		USG_VGC.xPRESS_OK := FALSE;
    		USG_VGC.xAT_VAC := FALSE;
    		USG_VGC.sPath:=  'MR1K4_SOMS_GCC_1';
    	END_IF

        IF USVacOk_HI THEN 
    		USG_PIP.rPRESS := 5E-5;
    		USG_PIP.xPRESS_OK := TRUE;
    		USG_PIP.xAT_VAC := TRUE;
    		USG_PIP.sPath:=  'MR1K4_SOMS_GCC_1';
    	ELSE
    		USG_PIP.xPRESS_OK := FALSE;
    		USG_PIP.xAT_VAC := FALSE;
    		USG_PIP.sPath:=  'MR1K4_SOMS_GCC_1';
    	END_IF 

    	(* check other gauges*)
    	TV1K4_GPI_01(); 
    	ST1K4_TEST_GPI_01(); 
    	ST2K4_BCS_GPI_01();
    	PC4K4_XTES_GPI_01(); 
    	
    	TV1k4_GCC_01(PG:=TV1k4_GPI_01.PG , IG=> , bEP := TRUE );
    	ST1K4_TEST_GCC_01(PG:=ST1K4_TEST_GPI_01.PG , IG=> , bEP := TRUE); 
    	ST2K4_BCS_GCC_01(PG:=ST2K4_BCS_GPI_01.PG , IG=> , bEP := TRUE);
    	PC4K4_XTES_GCC_01(PG:=PC4K4_XTES_GPI_01.PG , IG=> , bEP := TRUE );
    		
    (* Valves*)
    (*example
    GEM1_VGC_10(i_stUSG := USG_GCC.IG, i_stDSG:= GEM1_GCC_10.IG,i_xDis_DPIlk := TRUE, i_xEPS_OK := TRUE,
    		i_xPMPS_OK := TRUE, i_xExt_OK := xGEM1_AperturesOpnOK, i_xOverrideMode := xGEM1OverrideMode,i_xReset := xFastFaultReset,io_fbFFHWO :=g_FastFaultOutput1);
    *)
    	
    	TV1K4_VGC_01(
    				i_stUSG := USG_VGC, 
    				i_stDSG:= TV1k4_GCC_01.IG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE , 
    				i_xExt_OK := TV1K4_VFS_Interface.i_xVAC_FAULT_OK, 
    				i_xOverrideMode := xSystemOverrideMode_FEE, 
    				i_xReset := xReset_PMPS_FFO1,
    				io_fbFFHWO :=g_FastFaultOutput1,
    				iq_stValve =>,
    				fbArbiter := g_fbArbiter1,
    				i_nTransitionRootID := 44816
    );
    	
     	TV1K4_VGC_02(
    				i_stUSG := TV1k4_GCC_01.IG, 
    				i_stDSG:= ST1K4_TEST_GCC_01.IG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE , 
    				i_xExt_OK := TRUE, 
    				i_xOverrideMode := xSystemOverrideMode_FEE, 
    				i_xReset := xReset_PMPS_FFO1,
    				io_fbFFHWO :=g_FastFaultOutput1,
    				iq_stValve =>,
                    fbArbiter := g_fbArbiter1,
    				i_nTransitionRootID := 44832
    				
    );
    	
    	ST3K4_PPS_VGC_01(
    				i_stUSG := ST2K4_BCS_GCC_01.IG, 
    				i_stDSG:= PC4K4_XTES_PIP_01.q_IG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE, 
    				i_xExt_OK := TRUE, 
    				i_xOverrideMode := xSystemOverrideMode_FEE, 
    				i_xReset := xReset_PMPS_FFO2,
    				io_fbFFHWO :=g_FastFaultOutput2,
    				iq_stValve =>,
                    fbArbiter := g_fbArbiter2,
    				i_nTransitionRootID := 44848
    );
    			
    (*Ion Pumps*)	
    	(*example
    	SP1L0_KMONO_PIP_01(i_stGauge:=SP1L0_KMONO_GCC_01.IG, stPump=>);*)		

    	MR1K4_SOMS_PIP_01(i_stGauge := USG_PIP, stPump=>);
    	TV1K4_PIP_01(i_stGauge := TV1K4_GCC_01.IG, stPump=>);
    	ST1K4_TEST_PIP_01(i_stGauge := ST1K4_TEST_GCC_01.IG, stPump=>);
    	ST2K4_BCS_PIP_01(i_stGauge := ST2K4_BCS_GCC_01.IG, stPump=>);
    	ST3K4_PPS_PIP_01(i_stGauge := ST2K4_BCS_GCC_01.IG, stPump=>);
    	PC4K4_XTES_PIP_01(i_stGauge := PC4K4_XTES_GPI_01.PG, stPump=>);

    END_PROGRAM




PRG_FSV
^^^^^^^

::

    PROGRAM PRG_FSV
    VAR
    	fastFaultSaveMyLife : FB_FastFault;
        bM1K1Veto_IN : BOOL;
    	bST3K4Veto_IN: BOOL;
    	bST4K4Veto_IN: BOOL;
    	ff6_ff4_link_vac: FB_FastFault := (i_xAutoReset := TRUE, i_DevName := 'FF6 to FF4 Link', i_Desc := 'Do not bypass! This is virtual FF6 fault, Please check ST4K4 downstream MR4K4_FSV ', i_TypeCode := 16#9999);
    	fb_VetoArbiter2: FB_VetoArbiter;
    END_VAR
    TV1K4_VFS_1(
    	i_xPMPS_OK:= TRUE, 
    	i_xExt_OK:= TRUE, 
    	i_xVeto_Enable:=TRUE,
    	i_sDevName:= 'TV1K4:VFS:01', 
    	io_fbFFHWO:= GVL_PMPS.g_FastFaultOutput3 );
    	
    MR3K4_KBO_VFS_1(
    	i_xPMPS_OK:= TRUE, 
    	i_xExt_OK:= TRUE, 
    	i_xVeto_Enable:=TRUE,
    	i_sDevName:= 'MR3K4:KBO:VFS:1',
    	io_fbFFHWO:= GVL_PMPS.g_FastFaultOutput4
    );



    MR4K4_KBO_VFS_1(
    	i_xPMPS_OK:= TRUE, 
    	i_xExt_OK:= TRUE, 
    	i_xVeto_Enable:=TRUE,
    	i_sDevName:= 'MR4K4:KBO:VFS:1',
    	io_fbFFHWO:= GVL_PMPS.g_FastFaultOutput6
    );



    // M1K1 Veto
    bM1K1Veto_IN := NOT PMPS_GVL.stCurrentBeamParameters.aVetoDevices[PMPS.K_Stopper.MR1K1_OUT] 
                    AND PMPS_GVL.stCurrentBeamParameters.aVetoDevices[PMPS.K_Stopper.MR1K1_IN];
    bST3K4Veto_IN := PMPS_GVL.stCurrentBeamParameters.aVetoDevices[PMPS.K_Stopper.ST3K4] OR bM1K1Veto_IN;
    bST4K4Veto_IN := PMPS_GVL.stCurrentBeamParameters.aVetoDevices[PMPS.K_Stopper.ST4K4] OR bST3K4Veto_IN;

    (*FastFaultOuput*)	
    g_FastFaultOutput3.Execute(bAutoReset:= TRUE, i_xVeto:=bM1K1Veto_IN);

    g_FastFaultOutput4.Execute(i_xVeto:=PMPS_GVL.stCurrentBeamParameters.aVetoDevices[K_Stopper.ST3K4]
                                        OR bM1K1Veto_IN, bAutoReset:= TRUE);


    // Everything downstream of ST4K4
    g_FastFaultOutput6.Execute(i_xVeto:= bST4K4Veto_IN, bAutoReset:= TRUE);

    ff6_ff4_link_vac(
        io_fbFFHWO := GVL_PMPS.g_FastFaultOutput4,
        i_xOK := GVL_PMPS.g_FastFaultOutput6.q_xFastFaultOut);

    END_PROGRAM


Related:
    * `GVL_PMPS`_


PRG_FSV_Interfaces
^^^^^^^^^^^^^^^^^^

::

    PROGRAM PRG_FSV_Interfaces
    VAR
    END_VAR
    (*Vacuum Fast Shutter Valve*)
    TV1K4_VFS_Interface(IG1:=LI2K4_IP1_GFS_01.IG, IG2:=LI2K4_IP1_GFS_02.IG, IG3:=LI2K4_IP1_GFS_03.IG, Veto_Valve:=ST3K4_PPS_VGC_01.iq_stValve, i_e2OO3_MODE:=eVFS2OO3Mode_TMO);

    MR3K4_KBO_VFS_Interface(IG1:=LI2K4_IP1_GFS_01.IG, IG2:=LI2K4_IP1_GFS_02.IG, IG3:=LI2K4_IP1_GFS_03.IG, Veto_Valve:=MR3K4_KBO_VWC_01.iq_stValve, i_e2OO3_MODE:=eVFS2OO3Mode_TMO);

    MR4K4_KBO_VFS_Interface(IG1:=LI2K4_IP1_GFS_01.IG, IG2:=LI2K4_IP1_GFS_02.IG, IG3:=LI2K4_IP1_GFS_03.IG, Veto_valve:=MR4K4_KBO_VWC_01.iq_stValve, i_e2OO3_MODE:=eVFS2OO3Mode_TMO);

    END_PROGRAM




PRG_Hutch_Beamline_Valves
^^^^^^^^^^^^^^^^^^^^^^^^^

::

    PROGRAM PRG_Hutch_Beamline_Valves
    VAR
    	LAMP_C2_GCC_01: FB_MKS500; // wrong. only need temporary before integrate with LAMP 
    	xAll_Turbo_isRunning : BOOL := False;

    	
    	ton_PA1K4_IP1_PTM_01_notRunning : TON;
    	ton_PA1K4_IP1_PTM_02_notRunning : TON;
    	ton_PA1K4_IP1_PTM_03_notRunning : TON;
    	ton_IM4K4_PPM_PTM_01_notRunning : TON;
    	ton_LI1K4_IP1_PTM_01_notRunning : TON;
    	ton_LI3K4_IP1_OUT_PTM_01_notRunning : TON;
    	ton_TM1K4_PTM_01_notRunning : TON;
    	ton_IM5K4_PPM_PTM_01_notRunning : TON;
    	
    	tDelOK	:	TIME := T#30S;
    	xExtIlkOK : BOOL;

    	PA1K4_IP1_PTM_01_isRunning: BOOL;
    	PA1K4_IP1_PTM_02_isRunning: BOOL;
    	PA1K4_IP1_PTM_03_isRunning: BOOL;
    	IM4K4_PPM_PTM_01_isRunning: BOOL;
    	LI1K4_IP1_PTM_01_isRunning: BOOL;
    	LI3K4_IP1_OUT_PTM_01_isRunning: BOOL;
    	TM1K4_PTM_01_isRunning: BOOL;
    	IM5K4_PPM_PTM_01_isRunning: BOOL;
    	
    	xValves_are_OPN_OK : BOOL;
    	
    END_VAR
    (* Beamline window valves use VGC function. Valves allow to open when both upstream and downstream gauges
        reading pressure below than setpoints,  all turbo pumps are running and no faults, and all beamline valves
        in hutch are OPN_OK*)

    (* check turbo pump status	*)
    PA1K4_IP1_PTM_01_isRunning := PA1K4_IP1_PTM_01.iq_stPTM.eState = E_PumpState.pumpRUNNING;
    ton_PA1K4_IP1_PTM_01_notRunning(IN:= NOT PA1K4_IP1_PTM_01_isRunning, PT:=tDelOK);

    PA1K4_IP1_PTM_02_isRunning := PA1K4_IP1_PTM_02.iq_stPTM.eState = E_PumpState.pumpRUNNING;
    ton_PA1K4_IP1_PTM_02_notRunning(IN:= NOT PA1K4_IP1_PTM_02_isRunning, PT:=tDelOK);

    PA1K4_IP1_PTM_03_isRunning := PA1K4_IP1_PTM_03.iq_stPTM.eState = E_PumpState.pumpRUNNING;
    ton_PA1K4_IP1_PTM_03_notRunning(IN:= NOT PA1K4_IP1_PTM_03_isRunning, PT:=tDelOK);

    IM4K4_PPM_PTM_01_isRunning := IM4K4_PPM_PTM_01.iq_stPTM.eState = E_PumpState.pumpRUNNING;
    ton_IM4K4_PPM_PTM_01_notRunning(IN:= NOT IM4K4_PPM_PTM_01_isRunning, PT:=tDelOK);

    LI1K4_IP1_PTM_01_isRunning := LI1K4_IP1_PTM_01.iq_stPTM.eState = E_PumpState.pumpRUNNING;
    ton_LI1K4_IP1_PTM_01_notRunning(IN:= NOT LI1K4_IP1_PTM_01_isRunning, PT:=tDelOK);

    LI3K4_IP1_OUT_PTM_01_isRunning := LI3K4_IP1_OUT_PTM_01.iq_stPTM.eState = E_PumpState.pumpRUNNING;
    ton_LI3K4_IP1_OUT_PTM_01_notRunning(IN:= NOT LI3K4_IP1_OUT_PTM_01_isRunning, PT:=tDelOK);

    TM1K4_PTM_01_isRunning := TM1K4_PTM_01.iq_stPTM.eState = E_PumpState.pumpRUNNING;
    ton_TM1K4_PTM_01_notRunning(IN:= NOT TM1K4_PTM_01_isRunning, PT:=tDelOK);

    IM5K4_PPM_PTM_01_isRunning := IM5K4_PPM_PTM_01.iq_stPTM.eState = E_PumpState.pumpRUNNING;
    ton_IM5K4_PPM_PTM_01_notRunning(IN:= NOT IM5K4_PPM_PTM_01_isRunning, PT:=tDelOK);

    xTurboFault := ton_PA1K4_IP1_PTM_01_notRunning.Q OR ton_PA1K4_IP1_PTM_02_notRunning.Q OR
                   ton_PA1K4_IP1_PTM_03_notRunning.Q OR ton_IM4K4_PPM_PTM_01_notRunning.Q OR
    			   ton_LI1K4_IP1_PTM_01_notRunning.Q OR ton_LI3K4_IP1_OUT_PTM_01_notRunning.Q OR
    				ton_TM1K4_PTM_01_notRunning.Q OR ton_IM5K4_PPM_PTM_01_notRunning.Q 
    				OR NOT IP1_TURBOS_ALL_AtSpd;

    (* check beamline valve OPEN permit *)	
    (*xValves_are_OPN_OK :=  MR2K4_KBO_VWC_01.iq_stValve.xOPN_OK AND MR3K4_KBO_VWC_01.iq_stValve.xOPN_OK AND
                           LI3K4_IP1_VWC_01.iq_stValve.xOPN_OK AND PC5K4_VWC_01.iq_stValve.xOPN_OK ; *) 

    (*if not all beamline valves are OPN_OK, close all beamline valves*)
    (*IF NOT xValves_are_OPN_OK Then
    	MR2K4_KBO_VWC_01.M_Set_OPN_SW(false);	
    	MR3K4_KBO_VWC_01.M_Set_OPN_SW(false);
    	LI3K4_IP1_VWC_01.M_Set_OPN_SW(false);
    	PC5K4_VWC_01.M_Set_OPN_SW(false);
    	xBeamlineValveFault := True;
    ElSE
       xBeamlineValveFault := False;	
    END_IF
    *)					   
       
    					 

    MR2K4_KBO_VWC_01(
    				i_stUSG := PC4K4_XTES_PIP_01.q_IG, 
    				i_stDSG:= MR2K4_KBO_GCC_01.IG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE , 
    				i_xExt_OK := NOT xTurboFault, 
    				i_xOverrideMode := xSystemOverrideMode_TMO, 
    				i_xReset := xReset_PMPS_FFO2,
    				iq_stValve =>,
    				io_fbFFHWO :=g_FastFaultOutput2,
                    fbArbiter := g_fbArbiter2,
    				i_nTransitionRootID := 47632,
    				i_sDevName := 'MR2K4-KBO-VWC-01'
    				
    );


    MR3K4_KBO_VWC_01(
    				i_stUSG := MR2K4_KBO_GCC_01.IG, 
    				i_stDSG:= PA1K4_IP1_GCC_01.IG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE , 
    				i_xExt_OK := NOT xTurboFault AND MR3K4_KBO_VFS_Interface.i_xVAC_FAULT_OK, 
    				i_xOverrideMode := xSystemOverrideMode_TMO, 
    				i_xReset := xReset_PMPS_FFO2,
    				iq_stValve =>,
    				io_fbFFHWO :=g_FastFaultOutput2,
                    fbArbiter := g_fbArbiter2,
    				i_nTransitionRootID := 47648,
    				i_sDevName := 'MR3K4-KBO-VWC-01'
    				
    );

    LI3K4_IP1_VWC_01(
    				i_stUSG := IP1_MAIN_GAUGE.VG, 
    				i_stDSG:= IM5K4_PPM_GCC_01.IG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE , 
    				i_xExt_OK := NOT xTurboFault, 
    				i_xOverrideMode := xSystemOverrideMode_TMO,
    				i_xReset := xReset_PMPS_FFO2,
    				iq_stValve =>,
    				io_fbFFHWO :=g_FastFaultOutput2,
                    fbArbiter := g_fbArbiter2,
    				i_nTransitionRootID := 47664,
    				i_sDevName := 'LI3K4-IP1-VWC-01'
    );

    PC5K4_VWC_01(
    				i_stUSG := IM5K4_PPM_GCC_01.IG, 
    				i_stDSG:= PA2K4_IP1_GCC_01.IG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE, 
    				i_xExt_OK := NOT xTurboFault, 
    				i_xOverrideMode := xSystemOverrideMode_TMO, 
    				i_xReset := xReset_PMPS_FFO5,
    				iq_stValve =>,
    				io_fbFFHWO :=g_FastFaultOutput5,
                    fbArbiter := g_fbArbiter3,
    				i_nTransitionRootID := 47680,
    				i_sDevName := 'PC5K4-VWC-01'
    );

    MR4K4_KBO_VWC_01(
    				i_stUSG := PA2K4_IP1_GCC_01.IG, 
    				i_stDSG:= MR4K4_KBO_GCC_01.IG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE, 
    				i_xExt_OK := NOT xTurboFault,
    				i_xOverrideMode := xSystemOverrideMode_TMO, 
    				i_xReset := xReset_PMPS_FFO2,
    				iq_stValve =>,
    				io_fbFFHWO :=g_FastFaultOutput5,
                    fbArbiter := g_fbArbiter3,
    				i_nTransitionRootID := 47696,
    				i_sDevName := 'MR4K4-KBO-VWC-01'
    );
    // when dream arrives, this needs to be changes to dream gauge(downstream)	
    MR5K4_KBO_VWC_01(
    				i_stUSG := MR4K4_KBO_GCC_01.IG, 
    				i_stDSG:= TM2K4_KBO_GCC_01.IG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE, 
    				i_xExt_OK := NOT xTurboFault,
    				i_xOverrideMode := xSystemOverrideMode_TMO, 
    				i_xReset := xReset_PMPS_FFO2,
    				iq_stValve =>,
    				io_fbFFHWO :=g_FastFaultOutput5,
                    fbArbiter := g_fbArbiter3,
    				i_nTransitionRootID := 47697,
    				i_sDevName := 'MR5K4-KBO-VWC-01'
    );
    //Currently there is no dream, so TM2K4 valve is always open during this configuration
    TM2K4_KBO_VWC_01(
    				i_stUSG := TM2K4_KBO_GCC_01.IG, 
    				i_stDSG:= TM2K4_KBO_GCC_01.IG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE, 
    				i_xExt_OK := NOT xTurboFault, 
    				i_xOverrideMode := xSystemOverrideMode_TMO, 
    				i_xReset := xReset_PMPS_FFO5,
    				iq_stValve =>,
    				io_fbFFHWO :=g_FastFaultOutput5,
                    fbArbiter := g_fbArbiter3,
    				i_nTransitionRootID := 47698,
    				i_sDevName := 'TM2K4-KBO-VWC-01'
    );

    END_PROGRAM




PRG_Hutch_Gauges
^^^^^^^^^^^^^^^^

::

    PROGRAM PRG_Hutch_Gauges
    VAR
    END_VAR
    (* Roughing Gauges *)
    	TMO_ROUGH1_GPI_01.M_SetBits(32767);
    	TMO_ROUGH1_GPI_01(PG=>);

    	TMO_ROUGH1_GPI_02.M_SetBits(32767);
    	TMO_ROUGH1_GPI_02(PG=>);

    	TMO_ROUGH1_GPI_03.M_SetBits(32767);
    	TMO_ROUGH1_GPI_03(PG=>);

    	TMO_ROUGH2_GPI_01.M_SetBits(32767);
    	TMO_ROUGH2_GPI_01(PG=>);
    	
    	TMO_ROUGH2_GPI_02.M_SetBits(32767);
    	TMO_ROUGH2_GPI_02(PG=>);
    	
    	


    (* Beamline Pirani & Cold Cathode*)
    	MR2K4_KBO_GPI_01.M_SetBits(30518);
    	MR2K4_KBO_GPI_01(); 
    	
    	MR2K4_KBO_GCC_01.M_SetBits(30518);
    	MR2K4_KBO_GCC_01(PG:=MR2K4_KBO_GPI_01.PG , IG=> );

    	PA1K4_IP1_GPI_01.M_SetBits(30518);	
    	PA1K4_IP1_GPI_01(); 

    	PA1K4_IP1_GCC_01.M_SetBits(30518);
    	PA1K4_IP1_GCC_01(PG:=PA1K4_IP1_GPI_01.PG , IG=> );

    	IM4K4_PPM_GCC_01.M_SetBits(30518);	
    	IM4K4_PPM_GCC_01(PG:=PA1K4_IP1_GPI_01.PG , IG=> );

    	LI2K4_IP1_GFS_01(PG:=PA1K4_IP1_GPI_01.PG , IG=> );
    	LI2K4_IP1_GFS_02(PG:=PA1K4_IP1_GPI_01.PG , IG=> );
    	LI2K4_IP1_GFS_03(PG:=PA1K4_IP1_GPI_01.PG , IG=> );
    	
    	TM1K4_GCC_01.M_SetBits(30518);
    	TM1K4_GCC_01(PG:=TMO_ROUGH1_GPI_03.PG , IG=> );


    	IM5K4_PPM_GCC_01.M_SetBits(30518);	
    	IM5K4_PPM_GCC_01(PG:=TMO_ROUGH1_GPI_03.PG , IG=> );
    	
    	PA2K4_IP1_GPI_01.M_SetBits(30518);
    	PA2K4_IP1_GPI_01();
    	
    	PA2K4_IP1_GCC_01.M_SetBits(30518);
    	PA2K4_IP1_GCC_01(PG:=PA2K4_IP1_GPI_01.PG , IG=> );

    	MR4K4_KBO_GPI_01.M_SetBits(30518);	
    	MR4K4_KBO_GPI_01();
    	
    	MR4K4_KBO_GCC_01.M_SetBits(30518);	
    	MR4K4_KBO_GCC_01(PG:=MR4K4_KBO_GPI_01.PG , IG=> );
    	
    	TM2K4_KBO_GCC_01.M_SetBits(30518);
    	TM2K4_KBO_GCC_01(PG:=TM2K4_KBO_GPI_01.PG , IG=> );
    	
    	TM2K4_KBO_GPI_01.M_SetBits(30518);	
    	TM2K4_KBO_GPI_01();
    	
    	PF2K4_WFS_GCC_01.M_SetBits(30518);
    	PF2K4_WFS_GCC_01(PG:=TM2K4_KBO_GPI_01.PG , IG=> );

    //Read IP1 main chamber pressure

      IP1_MAIN_GAUGE( VG=> );
     
    	

    (* Auto switch on cold cathode gauges if interlock permits *)

    If xGCC_Enable_SW THEN
    	
    	MR2K4_KBO_GCC_01.M_HVE(TRUE);
    	PA1K4_IP1_GCC_01.M_HVE(TRUE);
    	IM4K4_PPM_GCC_01.M_HVE(TRUE);
    	TM1K4_GCC_01.M_HVE(TRUE);
    	IM5K4_PPM_GCC_01.M_HVE(TRUE);
    	PA2K4_IP1_GCC_01.M_HVE(TRUE);
    	MR4K4_KBO_GCC_01.M_HVE(TRUE);
    	TM2K4_KBO_GCC_01.M_HVE(TRUE);
    	PF2K4_WFS_GCC_01.M_HVE(TRUE);
    	xGCC_Enable_SW := False;
    END_IF

    END_PROGRAM




PRG_Hutch_Ion_Pumps
^^^^^^^^^^^^^^^^^^^

::

    PROGRAM PRG_Hutch_Ion_Pumps
    VAR
    END_VAR
    MR2K4_KBO_PIP_01(i_stGauge := MR2K4_KBO_GPI_01.PG, stPump=>);
    	PA2K4_IP1_PIP_01(i_stGauge := PA2K4_IP1_GCC_01.IG, stPump=>);
    	MR4K4_KBO_PIP_01(i_stGauge := MR4K4_KBO_GCC_01.IG, stPump=>);

    END_PROGRAM




PRG_HV_SAFETY
^^^^^^^^^^^^^

::

    PROGRAM PRG_HV_SAFETY
    VAR
    END_VAR
    iHV_LOOP_FIM_ON:= (MR2K4_KBO_GCC_01.IG.rPRESS <= iHV_LOOP_FIM_PRESSURE) AND (MR2K4_KBO_GCC_01.IG.xPRESS_OK = TRUE);

    END_PROGRAM




PRG_IP1_ECAT_Interfaces
^^^^^^^^^^^^^^^^^^^^^^^

::

    PROGRAM PRG_IP1_ECAT_Interfaces
    VAR
    END_VAR
    ROUGH1_VRC_01_AtOpnLS := TMO_ROUGH1_VRC_01.iq_stValve.i_xOpnLS;
    ROUGH2_VRC_01_AtOpnLS := TMO_ROUGH2_VRC_01.iq_stValve.i_xOpnLS;

    END_PROGRAM




PRG_PMPS
^^^^^^^^

::

    PROGRAM PRG_PMPS
    VAR
    	fbArbiterIO : FB_SubSysToArbiter_IO;
    	bRemove: BOOL;
    	bRemove2: BOOL;
    	bExist: BOOL;
    	bExist2: BOOL;
    	ID: UDINT;
    	fb_VetoArbiter: FB_VetoArbiter;
        ff5_ff2_link_vac: FB_FastFault := (i_xAutoReset := TRUE, i_DevName := 'FF5 to FF2 Link', i_Desc := 'This is virtual FF5 fault, Please check ST4K4 downstream faulting device ', i_TypeCode := 16#9999);
    	fb_VetoArbiter2: FB_VetoArbiter;
        bM1K1Veto_IN : BOOL;
    	bST3K4Veto_IN: BOOL;
    	bST4K4Veto_IN: BOOL;
    END_VAR
    bM1K1Veto_IN := NOT PMPS_GVL.stCurrentBeamParameters.aVetoDevices[PMPS.K_Stopper.MR1K1_OUT] 
                    AND PMPS_GVL.stCurrentBeamParameters.aVetoDevices[PMPS.K_Stopper.MR1K1_IN];
    bST3K4Veto_IN := PMPS_GVL.stCurrentBeamParameters.aVetoDevices[PMPS.K_Stopper.ST3K4] OR bM1K1Veto_IN;
    bST4K4Veto_IN := PMPS_GVL.stCurrentBeamParameters.aVetoDevices[PMPS.K_Stopper.ST4K4] OR bST3K4Veto_IN;

    (*FastFaultOuput*)
    // Everything upstream ST3K4
    g_FastFaultOutput1.Execute(i_xVeto:=bM1K1Veto_IN, bAutoReset:= TRUE);

    // Everything downstream of ST3K4
    g_FastFaultOutput2.Execute(i_xVeto:= bST3K4Veto_IN, bAutoReset:= TRUE);

    // Everything downstream of ST4K4
    g_FastFaultOutput5.Execute(i_xVeto:= bST4K4Veto_IN, bAutoReset:= TRUE);

    ff5_ff2_link_vac(
        io_fbFFHWO := GVL_PMPS.g_FastFaultOutput2,
        i_xOK := GVL_PMPS.g_FastFaultOutput5.q_xFastFaultOut);

    // Preemptive system
    fbArbiterIO(Arbiter := g_fbArbiter1, fbFFHWO := g_FastFaultOutput1,
    	i_bVeto := bM1K1Veto_IN);
        
    //fb_VetoArbiter(bVeto:= PMPS_GVL.stCurrentBeamParameters.aVetoDevices[PMPS.K_Stopper.ST3K4],
    //		HigherAuthority:=g_fbArbiter1 , 
    //		LowerAuthority:= g_fbArbiter2 , FFO:= g_FastFaultOutput2);

    //Test and diagnostic stuff
    bExist:= g_fbArbiter1.CheckRequestInPool(ID);
    bExist2:= g_fbArbiter2.CheckRequestInPool(ID);
    if (bRemove) THEN
    	g_fbArbiter1.RemoveRequest(ID);
    END_IF
    if (bRemove2) THEN
    	g_fbArbiter2.RemoveRequest(ID);
    END_IF

    g_fbArbiter1.AddRequest(nReqID := 131313, stReqBp := PMPS_GVL.cstFullBeam, sDevName := 'plc-tmo-vac');

    END_PROGRAM


Related:
    * `GVL_PMPS`_


PRG_Roughing_Pumps
^^^^^^^^^^^^^^^^^^

::

    PROGRAM PRG_Roughing_Pumps
    VAR
    	
    	xRough1Vrc01_OpenOK: BOOL := False;
    	xRough1Vrc02_OpenOK: BOOL := False;
    	xRough2Vrc01_OpenOK: BOOL := False;
    	dummy_FFFO : FB_HardwareFFOutput;
    	dummy_fbArbiter1    :   FB_Arbiter(1);
    		
    	PA1K4_IP1_PTM_01_xExtIlkOK: BOOL := FALSE;
    	PA1K4_IP1_PTM_02_xExtIlkOK: BOOL := FALSE;
    	PA1K4_IP1_PTM_03_xExtIlkOK: BOOL := False;
    	
    	f_trig_r1 : F_TRIG;
    	f_trig_r2 : F_TRIG;
    	r_trig_r1 : R_TRIG;
    	r_trig_r2 : R_TRIG;

    	tonDelOK : TON;
    	tDelOK	:	TIME := T#30S;
    	xExtIlkOK : BOOL;
    	
    	tonDelSW : TON;
    	
    	
    	IM4K4_PPM_PTM_01_xExtIlkOK: BOOL := FALSE;
    	LI1K4_IP1_PTM_01_xExtIlkOK: BOOL := FALSE;
    	LI3K4_IP1_OUT_PTM_01_xExtIlkOK: BOOL := False;
    	IM5K4_PPM_PTM_01_xExtIlkOK: BOOL := False;
    	
    	rTolerance : REAL;
    	xDifPressureOK : BOOL := FALSE;
    	TMO_ROUGH1_VRC_01_xExt_OK : BOOL;
    	TMO_ROUGH1_VRC_02_xExt_OK : BOOL;
    	TMO_ROUGH2_VRC_01_xExt_OK : BOOL;
    	
    	xLAMP_VRC01_VRC02_atOpnLS: BOOL;
    END_VAR

    VAR RETAIN
    	TM1K4_PTM_01_xExtIlkOK: BOOL := False;
    END_VAR
    (* Roughing Valves *)

    (* All three roughing valves permit to open when both side reading pressure below than setpoint, 1E-3 for both sides.
       When chamber is vented, bypass to open valve to pump down. 
       FB_VGC_2S is used for VRC controls.
       
       For TMO_ROUGH1_VRC_01 & TMO_ROUGH1_VRC_02, additional interlock is implemented using i_xExt_OK input of VGC function:
       If pressure difference between TMO_ROUGH1_GPI_02 and TMO_ROUGH1_GPI_03 is greater than 20 Torr, 
       only one of them permit to open.
       
       For TMO_ROUGH1_VRC_01 & TMO_ROUGH2_VRC_01 if one closed, wait for 10s, close the other.
       
    *)


    (* Check the pressure difference between TMO_ROUGH1_GPI_02 and TMO_ROUGH1_GPI_03 *) 



    rTolerance := 0.1;
    xDifPressureOK := (ABS(TMO_ROUGH1_GPI_02.PG.rPRESS - TMO_ROUGH1_GPI_03.PG.rPRESS ) <= rTolerance ) AND
    				  TMO_ROUGH1_GPI_02.PG.xPRESS_OK AND TMO_ROUGH1_GPI_03.PG.xPRESS_OK;
    				  
    (* Set Rough1_vrc_01 external interlock OK TRUE, when:
         xDifPressureOK or TMO_ROUGH1_VRC_02 is closed 
         AND if LAMP is connected, LAMP_ROUGH_VRC01 and VRC02 are open OR TMO_ROUGH2_VRC01 is open. *)	
    	 
    //xEcatBridge_COM_ERROR := TRUE means that there is an EtherCAT Bridge Communication error.
    IP1_ECAT_COM_ERROR := (xEcatBridge_TxPDO_state OR xEcatBridge_External_device_not_connected OR xEcatBridge_WcState);

    xLAMP_VRC01_VRC02_atOpnLS := IP1_ROUGH_VRC_01_AtOpnLS AND NOT IP1_ECAT_COM_ERROR 
                                  AND IP1_ROUGH_VRC_02_AtOpnLS AND NOT IP1_ECAT_COM_ERROR;
    			  
    TMO_ROUGH1_VRC_01_xExt_OK := ( xDifPressureOK OR TMO_ROUGH1_VRC_02.iq_stValve.i_xClsLS )
                                AND ( 
                                      IP1_ROUGH_VRC_01_AtOpnLS 
                                      AND NOT IP1_ECAT_COM_ERROR 
                                      and TMO_ROUGH2_VRC_01.iq_stValve.i_xOpnLS 
                                      OR xLAMP_VRC01_VRC02_atOpnLS 
                                     );


    (* Set external interlock OK TRUE, when xDifPressureOK or TMO_ROUGH1_VRC_01 is closed *)	
    							  
    TMO_ROUGH1_VRC_02_xExt_OK := xDifPressureOK  OR TMO_ROUGH1_VRC_01.iq_stValve.i_xClsLS; 


    TMO_ROUGH1_VRC_01(
    				i_stUSG := TMO_ROUGH1_GPI_02.PG, 
    				i_stDSG:= TMO_ROUGH1_GPI_01.PG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE, 
    				i_xExt_OK := TMO_ROUGH1_VRC_01_xExt_OK, 
    				i_xOverrideMode := xSystemOverrideMode_TMO AND TMO_ROUGH1_VRC_01_xExt_OK,
    				i_xReset := False,
    				io_fbFFHWO :=dummy_FFFO,
                    fbArbiter := dummy_fbArbiter1,
    );




    TMO_ROUGH1_VRC_02(
    				i_stUSG := TMO_ROUGH1_GPI_03.PG, 
    				i_stDSG:= TMO_ROUGH1_GPI_01.PG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE, 
    				i_xExt_OK := TMO_ROUGH1_VRC_02_xExt_OK, 
    				i_xOverrideMode := xSystemOverrideMode_TMO AND TMO_ROUGH1_VRC_02_xExt_OK, 
    				i_xReset := false,
    				io_fbFFHWO :=dummy_FFFO,
                    fbArbiter := dummy_fbArbiter1);

    				
    (* Set TMO_ROUGH2_VRC01 external interlock OK TRUE, if LAMP is connected, and either LAMP_ROUGH_VRC01, VRC02 and VRC03 are open 
                        or both TMO_ROUGH1_VRC_01 and lamp_rough_vrc03 are open*)	

    TMO_ROUGH2_VRC_01_xExt_OK := NOT IP1_ECAT_COM_ERROR AND 
                            (  (IP1_ROUGH_VRC_01_AtOpnLS AND NOT IP1_ECAT_COM_ERROR  
                                                            AND IP1_ROUGH_VRC_02_AtOpnLS AND NOT IP1_ECAT_COM_ERROR
                                                            AND IP1_ROUGH_VRC_03_AtOpnLS AND NOT IP1_ECAT_COM_ERROR )                                      
                              OR ( TMO_ROUGH1_VRC_01.iq_stValve.i_xOpnLS and IP1_ROUGH_VRC_03_AtOpnLS AND NOT IP1_ECAT_COM_ERROR)
                              ) ; 				

    TMO_ROUGH2_VRC_01(
    				i_stUSG := TMO_ROUGH2_GPI_02.PG, 
    				i_stDSG:= TMO_ROUGH2_GPI_01.PG, 
    				i_xDis_DPIlk := FALSE, 
    				i_xEPS_OK := TRUE,
    				i_xPMPS_OK := TRUE, 
    				i_xExt_OK := TMO_ROUGH2_VRC_01_xExt_OK, 
    				i_xOverrideMode := xSystemOverrideMode_TMO, 
    				i_xReset := false,
    				io_fbFFHWO :=dummy_FFFO,
                    fbArbiter := dummy_fbArbiter1);


    			
    				
    (* Granite 1 K4S2 Differential Turbo pumps *)


    (* check if PA1K4_IP1_PTM_03 is Atspd, if it is starting, set up a timer for 30s to *)

    xExtIlkOK := F_Turbo_Protection_ILK(i_stTurbo := PA1K4_IP1_PTM_01.iq_stPTM, 
    			i_stISG := TMO_ROUGH1_GPI_02.PG, 
    			i_stBSG := TMO_ROUGH1_GPI_02.PG, 
    			iq_stValve := TMO_ROUGH1_VRC_01.iq_stValve)	;
    					
    (* delay 30s to start if PTM03 is not at speed*)
    IF (PA1K4_IP1_PTM_03.iq_stPTM.i_xAtSpd) AND (NOT PA1K4_IP1_PTM_03.iq_stPTM.i_xFault) THEN
    		PA1K4_IP1_PTM_01_xExtIlkOK := xExtIlkOK;

    ELSIF (PA1K4_IP1_PTM_03.iq_stPTM.q_RunDO ) AND (NOT PA1K4_IP1_PTM_03.iq_stPTM.i_xFault ) THEN
    	//delay timer
      	  tonDelOK(IN:= xExtIlkOK, PT:=tDelOK);
    	PA1K4_IP1_PTM_01_xExtIlkOK := xExtIlkOK AND tonDelOK.Q;	
    ELSE
    		PA1K4_IP1_PTM_01_xExtIlkOK := FALSE;			
    END_IF


    xExtIlkOK := F_Turbo_Protection_ILK(i_stTurbo := PA1K4_IP1_PTM_02.iq_stPTM, 
    			i_stISG := TMO_ROUGH1_GPI_02.PG, 
    			i_stBSG := TMO_ROUGH1_GPI_02.PG, 
    			iq_stValve := TMO_ROUGH1_VRC_01.iq_stValve)	;

    IF (PA1K4_IP1_PTM_03.iq_stPTM.i_xAtSpd) AND (NOT PA1K4_IP1_PTM_03.iq_stPTM.i_xFault) THEN
    		PA1K4_IP1_PTM_02_xExtIlkOK := xExtIlkOK;

    ELSIF (PA1K4_IP1_PTM_03.iq_stPTM.q_RunDO ) AND (NOT PA1K4_IP1_PTM_03.iq_stPTM.i_xFault ) THEN
    	//delay timer
      	  tonDelOK(IN:= xExtIlkOK, PT:=tDelOK);
    	PA1K4_IP1_PTM_02_xExtIlkOK := xExtIlkOK AND tonDelOK.Q;	
    ELSE
    		PA1K4_IP1_PTM_02_xExtIlkOK := FALSE;			
    END_IF

    PA1K4_IP1_PTM_03_xExtIlkOK  := F_Turbo_Protection_ILK(i_stTurbo := PA1K4_IP1_PTM_03.iq_stPTM, 
    			i_stISG := TMO_ROUGH1_GPI_02.PG, 
    			i_stBSG := TMO_ROUGH1_GPI_02.PG, 
    			iq_stValve := TMO_ROUGH1_VRC_01.iq_stValve)	;


    PA1K4_IP1_PTM_01(i_xExtIlkOK := PA1K4_IP1_PTM_01_xExtIlkOK , iq_stPTM => );

    PA1K4_IP1_PTM_02(i_xExtIlkOK := PA1K4_IP1_PTM_02_xExtIlkOK, iq_stPTM => );
    PA1K4_IP1_PTM_03(i_xExtIlkOK := PA1K4_IP1_PTM_03_xExtIlkOK, iq_stPTM => );

    (*Serial Interface*)
    (*Assign adresses to the pfeiffer controllers connected to this serial terminal*)
    st_Pfeiffer_CTRL_PTM_01_02_03[1].iSerialAddress :=10;//PA1K4_IP1_PTM_01
    st_Pfeiffer_CTRL_PTM_01_02_03[1].xEnableComm := TRUE;
    st_Pfeiffer_CTRL_PTM_01_02_03[2].iSerialAddress :=9;//PA1K4_IP1_PTM_02
    st_Pfeiffer_CTRL_PTM_01_02_03[2].xEnableComm := TRUE;
    st_Pfeiffer_CTRL_PTM_01_02_03[3].iSerialAddress :=1;//PA1K4_IP1_PTM_03
    st_Pfeiffer_CTRL_PTM_01_02_03[3].xEnableComm := TRUE;	
    (* Instanitate the Function block for serial communication with Pfeiffer*)	
    PA1K4_IP1_PTM_01_02_03_COM(astPfeifferControl := st_Pfeiffer_CTRL_PTM_01_02_03,
    			   astPfeifferStatus:= st_Pfeiffer_RBK_PTM_01_02_03,
    				SerialRXBuffer:= K4S2_02_E10_SerialRXBuffer,
    				SerialTXBuffer:= K4S2_02_E10_SerialTXBuffer);
    (* Copy Status Pv's into the PTM structure*)
    PA1K4_IP1_PTM_01.M_Serial_IO(st_Pfeiffer_CTRL:=st_Pfeiffer_CTRL_PTM_01_02_03[1],st_Pfeiffer_RBK:=st_Pfeiffer_RBK_PTM_01_02_03[1]);				
    PA1K4_IP1_PTM_02.M_Serial_IO(st_Pfeiffer_CTRL:=st_Pfeiffer_CTRL_PTM_01_02_03[2],st_Pfeiffer_RBK:=st_Pfeiffer_RBK_PTM_01_02_03[2]);				
    PA1K4_IP1_PTM_03.M_Serial_IO(st_Pfeiffer_CTRL:=st_Pfeiffer_CTRL_PTM_01_02_03[3],st_Pfeiffer_RBK:=st_Pfeiffer_RBK_PTM_01_02_03[3]);				
    		
    (* Leybold turbo pumps on Granite 1 *)

    IM4K4_PPM_PTM_01_xExtIlkOK := F_Turbo_Protection_ILK(i_stTurbo := IM4K4_PPM_PTM_01.iq_stPTM, 
    			i_stISG := TMO_ROUGH1_GPI_02.PG, 
    			i_stBSG := TMO_ROUGH1_GPI_02.PG, 
    			iq_stValve := TMO_ROUGH1_VRC_01.iq_stValve)	;

    IM4K4_PPM_PTM_01(i_xExtIlkOK := IM4K4_PPM_PTM_01_xExtIlkOK, iq_stPTM => );



    (* Instanitate the Function block for serial communication with TD20 *)
    IM4K4_PPM_PTM_01_COM(SerialRXBuffer := K4S2_02_E17_SerialRXBuffer, 
    				SerialTXBuffer:= K4S2_02_E17_SerialTXBuffer,
    				astTD20Status=>);
    (* Copy Status Pv's into the PTM structure*)
    IM4K4_PPM_PTM_01.M_Serial_IO(IM4K4_PPM_PTM_01_COM.astTD20Status);



    LI1K4_IP1_PTM_01_xExtIlkOK := F_Turbo_Protection_ILK(i_stTurbo := LI1K4_IP1_PTM_01.iq_stPTM, 
    			i_stISG := TMO_ROUGH1_GPI_02.PG, 
    			i_stBSG := TMO_ROUGH1_GPI_02.PG, 
    			iq_stValve := TMO_ROUGH1_VRC_01.iq_stValve)	;
    			
    LI1K4_IP1_PTM_01(i_xExtIlkOK := LI1K4_IP1_PTM_01_xExtIlkOK, iq_stPTM => );

    (* Instanitate the Function block for serial communication with TD20 *)
    LI1K4_IP1_PTM_01_COM(SerialRXBuffer := K4S2_02_E18_SerialRXBuffer, 
    				SerialTXBuffer:= K4S2_02_E18_SerialTXBuffer,
    				astTD20Status=>);
    (* Copy Status Pv's into the PTM structure*)
    LI1K4_IP1_PTM_01.M_Serial_IO(LI1K4_IP1_PTM_01_COM.astTD20Status);



    (* Granite 2 K4S6 *)

    LI3K4_IP1_OUT_PTM_01_xExtIlkOK := F_Turbo_Protection_ILK(i_stTurbo := LI3K4_IP1_OUT_PTM_01.iq_stPTM, 
    			i_stISG := PA2K4_IP1_GPI_01.PG, 
    			i_stBSG := TMO_ROUGH1_GPI_03.PG, 
    			iq_stValve := TMO_ROUGH1_VRC_02.iq_stValve)	;

    LI3K4_IP1_OUT_PTM_01(i_xExtIlkOK := LI3K4_IP1_OUT_PTM_01_xExtIlkOK, iq_stPTM => );

    TM1K4_PTM_01_xExtIlkOK := F_Turbo_Protection_ILK(i_stTurbo := TM1K4_PTM_01.iq_stPTM, 
    			i_stISG := PA2K4_IP1_GPI_01.PG, 
    			i_stBSG := TMO_ROUGH1_GPI_03.PG, 
    			iq_stValve := TMO_ROUGH1_VRC_02.iq_stValve)	;

    TM1K4_PTM_01(i_xExtIlkOK := TM1K4_PTM_01_xExtIlkOK, iq_stPTM => );

    IM5K4_PPM_PTM_01_xExtIlkOK := F_Turbo_Protection_ILK(i_stTurbo := IM5K4_PPM_PTM_01.iq_stPTM, 
    			i_stISG := PA2K4_IP1_GPI_01.PG, 
    			i_stBSG := TMO_ROUGH1_GPI_03.PG, 
    			iq_stValve := TMO_ROUGH1_VRC_02.iq_stValve)	;
    			
    IM5K4_PPM_PTM_01(i_xExtIlkOK := IM5K4_PPM_PTM_01_xExtIlkOK, iq_stPTM => );

    (*Serial Interface*)
    (*Assign adresses to the pfeiffer controllers connected to this serial terminal*)
    st_Pfeiffer_CTRL_PTM_Granite2[1].iSerialAddress :=1;//LI3K4_IP1_OUT_PTM_01
    st_Pfeiffer_CTRL_PTM_Granite2[1].xEnableComm := TRUE;
    st_Pfeiffer_CTRL_PTM_Granite2[2].iSerialAddress :=7;//TM1K4_PTM_01
    st_Pfeiffer_CTRL_PTM_Granite2[2].xEnableComm := TRUE;
    st_Pfeiffer_CTRL_PTM_Granite2[3].iSerialAddress :=9; //IM5K4_PPM_PTM_01
    st_Pfeiffer_CTRL_PTM_Granite2[3].xEnableComm := TRUE;	
    (* Instanitate the Function block for serial communication with Pfeiffer*)	
    Granite2_PTM_COM(astPfeifferControl := st_Pfeiffer_CTRL_PTM_Granite2,
    			   astPfeifferStatus:= st_Pfeiffer_RBK_PTM_Granite2,
    				SerialRXBuffer:= K4S6_01_E5_SerialRXBuffer,
    				SerialTXBuffer:= K4S6_01_E5_SerialTXBuffer);
    (* Copy Status Pv's into the PTM structure*)
    LI3K4_IP1_OUT_PTM_01.M_Serial_IO(st_Pfeiffer_CTRL:=st_Pfeiffer_CTRL_PTM_Granite2[1],st_Pfeiffer_RBK:=st_Pfeiffer_RBK_PTM_Granite2[1]);				
    TM1K4_PTM_01.M_Serial_IO(st_Pfeiffer_CTRL:=st_Pfeiffer_CTRL_PTM_Granite2[2],st_Pfeiffer_RBK:=st_Pfeiffer_RBK_PTM_Granite2[2]);				
    IM5K4_PPM_PTM_01.M_Serial_IO(st_Pfeiffer_CTRL:=st_Pfeiffer_CTRL_PTM_Granite2[3],st_Pfeiffer_RBK:=st_Pfeiffer_RBK_PTM_Granite2[3]);

    END_PROGRAM


Related:
    * `F_Turbo_Protection_ILK`_


PRG_Section_2
^^^^^^^^^^^^^

::

    PROGRAM PRG_Section_2
    VAR
    END_VAR


    END_PROGRAM



